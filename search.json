                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  [{"title":"「数学」Menelaus定理与Ceva定理","url":"/2020/01/20/「数学」Menelaus定理与Ceva定理/","content":"内容$\\rm Menelaus$定理已知三角形$\\triangle ABC$被一直线所截，交三条边或三条边的延长线与点$X, Y, Z$点，则有$$\\frac{AX}{XB} \\cdot \\frac{BZ}{ZC} \\cdot \\frac{CY}{YA}=1$$（注：上图为一种情况，还有一种为“直线不经过三角形的任何一边，即与三角形的交点数为$0$”）证明：（未完待续）$\\rm Ceva$定理在三角形$\\triangle ABC$任取一点$O$，延长$AO$、$BO$、$CO$分别交对边于$x$、$y$、$z$，则有$$\\frac{AX}{XB} \\cdot \\frac{BZ}{ZC} \\cdot \\frac{CY}{YA}=1$$证明：（未完待续）","tags":["数学","三角形"],"categories":["数学"]},{"title":"春节倒计时","url":"/2019/12/31/春节倒计时/","content":"春节倒计时.middle{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;user-select:none;}.time{color:#8589ff;text-transform:uppercase;display:flex;justify-content:center;}.time span{padding:0 14px;font-size:0.8rem;}.time span div{font-size:3rem;}@media (max-width:740px){.time span{padding:0 16px;font-size:0.6rem;}.time span div{font-size:2rem;}}00Days  00Hours  00Minutes  00Seconds const comingdate = new Date(\"Jan 25, 2020 00:00:00\");const d = document.getElementById(\"d\");const h = document.getElementById(\"h\");const m = document.getElementById(\"m\");const s = document.getElementById(\"s\");const countdown = setInterval(() => {  const now   = new Date();  const des   = comingdate.getTime() - now.getTime();  const days  = Math.floor(des / (1000 * 60 * 60 * 24));  const hours = Math.floor((des % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));  const mins  = Math.floor((des % (1000 * 60 * 60)) / (1000 * 60));  const secs  = Math.floor((des % (1000 * 60)) / 1000);  d.innerHTML = getTrueNumber(days);  h.innerHTML = getTrueNumber(hours);  m.innerHTML = getTrueNumber(mins);  s.innerHTML = getTrueNumber(secs);  if (x  (x ","tags":["倒计时"],"categories":["新年"]},{"title":"「数学」三角函数公式以及部分证明","url":"/2019/12/15/「数学」三角函数公式以及部分证明/","content":"定义在$Rt\\triangle ABC$中，如下有六个三角函数的定义：正弦：$$\\sin A = \\frac{a}{c}$$级数表示：$\\sin (x)==\\sum_{k=0}^{\\infty} \\frac{(-1)^{k} x^{1+2k}}{(1+2k)!}$余弦：$$\\cos A = \\frac{b}{c}$$级数表示：$\\cos (x)=\\sum_{k=0}^{\\infty} \\frac{(-1)^{k} x^{2 k}}{(2 k) !}$正切：$$\\tan A = \\frac{a}{b}$$级数表示：$\\tan (x)=i+2 i \\sum_{k=1}^{\\infty}(-1)^{k} q^{2 k} \\color{gray}\\textrm{ for } q=e^{i x}$余切：$$\\cot A = \\frac{b}{a}$$级数表示：$\\cot (x)=-i-2 i \\sum_{k=1}^{\\infty} q^{2 k} \\color{gray}\\text { for } q=e^{i x}$正割：$$\\sec A = \\frac{c}{b}$$级数表示：$\\sec (x)=-2 \\sum_{k=1}^{\\infty}(-1)^{k} q^{-1+2 k} \\color{gray}\\text { for } q=e^{i x}$余割：$$\\csc A = \\frac{c}{a}$$级数表示：$\\csc (x)=-2 i \\sum_{k=1}^{\\infty} q^{-1+2 k} \\color{gray}\\text { for } q=e^{i x}$诱导公式链接关系 &amp; 定理 &amp; 公式倒数关系$$\\cos \\alpha \\cdot \\sec \\alpha = 1$$$$\\sin \\alpha \\cdot \\csc \\alpha = 1$$$$\\tan \\alpha \\cdot \\cot \\alpha = 1$$平方关系$$1 + \\tan ^ 2 \\alpha = \\sec ^ 2 \\alpha$$$$1 + \\cot ^ 2 \\alpha = \\csc ^ 2 \\alpha$$$$\\sin^2 \\alpha + cos ^ 2 \\alpha = 1$$商的关系$$\\frac{\\sin \\alpha}{\\cos \\alpha} = \\frac{\\sec \\alpha}{\\csc \\alpha} = \\tan \\alpha$$$$\\frac{\\cos \\alpha}{\\sin \\alpha} = \\frac{\\csc \\alpha}{\\sec \\alpha} = \\cot \\alpha$$正弦定理$$\\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C} = 2R = D$$$R$ 为三角形外切圆半径，$D$ 为三角形外切圆直径。证明：如图在 $\\triangle ABC$ 中可得 $\\sin A = \\frac{h}{b}$ 和 $\\sin B = \\frac{h}{a}$ 。$$\\therefore h = \\sin A \\times b, h = \\sin B \\times a \\\\\\ \\therefore \\sin A \\times b = \\sin B \\times a \\\\\\ \\therefore \\frac{\\sin A}{a} = \\frac{\\sin B}{b} \\\\\\ \\therefore \\frac{a}{\\sin A} = \\frac{b}{\\sin B} \\\\\\ \\textrm{同理：} \\frac{a}{\\sin A} = \\frac{c}{\\sin C} \\\\\\ \\therefore \\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C}$$如图， $\\triangle CDB$ 中线段 $CD$ 经过圆心，所以 $\\angle CBD = 90 ^ \\circ$ ， $CD = 2R$。$$\\therefore \\sin A = \\sin D = \\frac{CB}{CD} = \\frac{a}{2R} \\\\\\ \\therefore \\frac{a}{\\sin A} = 2R \\\\\\ \\textrm{同理：} \\frac{b}{\\sin B} = 2R, \\frac{c}{\\sin C} = 2R \\\\\\ \\therefore \\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C} = 2R = D$$余弦定理$$a ^ 2 = b ^ 2 + c ^ 2 - 2bc\\cos A, b ^ 2 = a ^ 2 + c ^ 2 - 2ac\\cos B, c ^ 2 = a ^ 2 + b ^ 2 - 2ab\\cos C \\\\\\ \\rm{或} \\\\\\ \\cos A = \\frac{b ^ 2 + c ^ 2 - a ^ 2}{2bc}, \\cos B = \\frac{a ^ 2 + c ^ 2 - b ^ 2}{2ac}, \\cos C = \\frac{a ^ 2 + b ^ 2 - c ^ 2}{2ab}$$证明：如图，在 $\\triangle ABC$ 中，令$\\vec{AB} = \\vec{c}, \\vec{CB} = \\vec{a}, \\vec{CA} = \\vec{b}$。$$\\therefore \\vec{c} = \\vec{AB} = \\vec{CB} - \\vec{CA} = \\vec{a} - \\vec{b} \\\\\\ \\therefore (\\vec{c}) ^ 2 = (\\vec{a} - \\vec{b}) ^ 2 = \\vec{a} ^ 2 + \\vec{b} ^ 2 - 2 \\vec{a} \\cdot \\vec{b} \\\\\\ \\therefore |\\vec{c}| ^ 2 = |\\vec{a}| ^ 2 + |\\vec{b}| ^ 2 - 2 |\\vec{a}| \\cdot |\\vec{b}| \\cdot \\cos C \\\\\\ \\therefore c ^ 2 = a ^ 2 + b ^ 2 - 2ab\\cos C \\\\\\ 同理：\\cos A = \\frac{b ^ 2 + c ^ 2 - a ^ 2}{2bc}, \\cos B = \\frac{a ^ 2 + c ^ 2 - b ^ 2}{2ac}$$和角公式$$\\sin(\\alpha + \\beta) = \\sin \\alpha \\cos \\beta + \\cos \\alpha \\sin \\beta$$$$\\cos(\\alpha + \\beta) = \\cos \\alpha \\cos \\beta - \\sin \\alpha \\sin \\beta$$$$\\tan(\\alpha + \\beta) = \\frac{\\tan \\alpha + \\tan \\beta}{1 - \\tan \\alpha \\tan \\beta}$$差角公式$$\\sin(\\alpha - \\beta) = \\sin \\alpha \\cos \\beta - \\cos \\alpha \\sin \\beta$$$$\\cos(\\alpha - \\beta) = \\cos \\alpha \\cos \\beta + \\sin \\alpha \\sin \\beta$$$$\\tan(\\alpha - \\beta) = \\frac{\\tan \\alpha - \\tan \\beta}{1 + \\tan \\alpha \\tan \\beta}$$和差化积$$\\sin \\alpha+\\sin \\beta=2 \\sin \\left(\\frac{\\alpha+\\beta}{2}\\right) \\cos \\left(\\frac{\\alpha-\\beta}{2}\\right)$$$$\\sin \\alpha-\\sin \\beta=2 \\sin \\left(\\frac{\\alpha-\\beta}{2}\\right) \\cos \\left(\\frac{\\alpha+\\beta}{2}\\right)$$$$\\cos \\alpha+\\cos \\beta=2 \\cos \\left(\\frac{\\alpha+\\beta}{2}\\right) \\cos \\left(\\frac{\\alpha-\\beta}{2}\\right)$$$$\\cos \\alpha-\\cos \\beta=-2 \\sin \\left(\\frac{\\alpha+\\beta}{2}\\right) \\sin \\left(\\frac{\\alpha-\\beta}{2}\\right)$$积化和差$$\\cos \\alpha \\sin \\beta=\\frac{1}{2}[\\sin (\\alpha+\\beta)-\\sin (\\alpha-\\beta)]$$$$\\sin \\alpha \\cos \\beta=\\frac{1}{2}[\\sin (\\alpha+\\beta)+\\sin (\\alpha-\\beta)]$$$$\\cos \\alpha \\cos \\beta=\\frac{1}{2}[\\cos (\\alpha+\\beta)+\\cos (\\alpha-\\beta)]$$$$\\sin \\alpha \\sin \\beta=-\\frac{1}{2}[\\cos (\\alpha+\\beta)-\\cos (\\alpha-\\beta)]$$倍角公式$$\\sin 2 \\alpha = 2 \\sin \\alpha \\cos \\alpha$$$$\\cos 2 \\alpha = \\cos ^ 2 \\alpha - \\sin ^ 2 \\alpha$$$$\\tan 2 \\alpha = \\frac{2 \\tan \\alpha}{1 - \\tan ^ 2 \\alpha}$$$$\\cot 2 \\alpha=\\frac{\\cot ^{2} \\alpha-1}{2 \\cot \\alpha}$$$$\\sec 2 \\alpha=\\frac{\\sec ^{2} \\alpha}{1-\\tan ^{2} \\alpha}$$$$\\csc 2 \\alpha=\\frac{1}{2} \\sec \\alpha \\csc \\alpha$$半角公式$$\\sin \\left(\\frac{\\alpha}{2}\\right) = \\sqrt{\\frac{1-\\cos \\alpha}{2}}$$$$\\cos \\left(\\frac{\\alpha}{2}\\right) = \\sqrt{\\frac{1+\\cos \\alpha}{2}}$$$$\\tan \\left(\\frac{\\alpha}{2}\\right) = \\csc \\alpha-\\cot \\alpha$$$$\\cot \\left(\\frac{\\alpha}{2}\\right) = \\csc \\alpha+\\cot \\alpha$$$$\\sec \\left(\\frac{\\alpha}{2}\\right) = \\sqrt{\\frac{2 \\sec \\alpha}{\\sec \\alpha+1}}$$$$\\csc \\left(\\frac{\\alpha}{2}\\right) = \\sqrt{\\frac{2 \\sec \\alpha}{\\sec \\alpha-1}}$$Attachment常用三角函数值对照表：角$\\alpha$弧度$\\sin$值$\\cos$值$\\tan$值$0^\\circ$$0$$0$$1$$0$$15^\\circ$$\\frac{\\pi}{12}$$\\frac{\\sqrt{6} - \\sqrt{2}}{4}$$\\frac{\\sqrt{6} + \\sqrt{2}}{4}$$2 - \\sqrt{3}$$22.5^\\circ$$\\frac{\\pi}{8}$$\\frac{\\sqrt{2 - \\sqrt{2}}}{2}$$\\frac{\\sqrt{2 + \\sqrt{2}}}{2}$$-1 + \\sqrt{2}$$30^\\circ$$\\frac{\\pi}{6}$$\\frac{1}{2}$$\\frac{\\sqrt{3}}{2}$$\\frac{\\sqrt{3}}{3}$$45^\\circ$$\\frac{\\pi}{4}$$\\frac{\\sqrt{2}}{2}$$\\frac{\\sqrt{2}}{2}$$1$$60^\\circ$$\\frac{\\pi}{3}$$\\frac{\\sqrt{3}}{2}$$\\frac{1}{2}$$\\sqrt{3}$$75^\\circ$$\\frac{5\\pi}{12}$$\\frac{\\sqrt{6} + \\sqrt{2}}{4}$$\\frac{\\sqrt{6} - \\sqrt{2}}{4}$$2 + \\sqrt{3}$$90^\\circ$$\\frac{\\pi}{2}$$1$$0$$\\rm{无}$$120^\\circ$$\\frac{2\\pi}{3}$$\\frac{\\sqrt{3}}{2}$$-\\frac{1}{2}$$-\\sqrt{3}$$135^\\circ$$\\frac{3\\pi}{4}$$\\frac{\\sqrt{2}}{2}$$-\\frac{\\sqrt{2}}{2}$$-1$$150^\\circ$$\\frac{5\\pi}{6}$$\\frac{1}{2}$$-\\frac{\\sqrt{3}}{2}$$\\frac{\\sqrt{3}}{3}$$180^\\circ$$\\pi$$0$$-1$$0$$270^\\circ$$\\frac{3\\pi}{2}$$-1$$0$$\\rm{无}$$360^\\circ$$2\\pi$$0$$1$$0$","tags":["数学","三角函数"],"categories":["数学"]},{"title":"「AT1175」ニコニコ文字列","url":"/2019/12/14/「AT1175」ニコニコ文字列/","content":"PortalPortal1: AtcoderPortal2: LuoguDescription$0$ から $9$ の数字から成る文字列 $S$ が与えられます。ある文字列 $X$ について、$X=$”$25$” または $X=$”$2525$” または $X=$”$252525$” …… というふうに “$25$” を何回か繰り返した文字列になっているとき、$X$ はニコニコ文字列であるといいます。 たとえば “$25$” や “$25252525$” はニコニコ文字列ですが、”$123$” や “$225$” はニコニコ文字列ではありません。あなたの仕事は、文字列 $S$ について、ニコニコ文字列となるような連続した部分文字列の取り出し方が何通りあるかを答えることです。 文字列として同じであっても、取り出し位置が異なっていれば別々に数えます。Input入力は以下の形式で標準入力から与えられる。$S$$1$ 行目には、文字列 $S$ が与えられる。Sの長さは $1$ 以上 $100,000$ 以下である。また、$S$ の各文字は $0$ から $9$ の数字のみから成る。Output$1$ 行目には、文字列 $S$ からニコニコ文字列となるような連続した部分文字列を取り出す方法が何通りあるかを出力せよ。行末の改行を忘れると不正解と判定されるので注意すること。Sample Input1Sample Output1Sample Input2Sample Output2Sample Input3Sample Output3Sample Input4Sample Output4Sample Input5Sample Output5Sample Explain1$S=$”$2525$”のケースです。部分文字列が “$25$” となる取り出し方が 2 通り、”$2525$” となる取り出し方が $1$ 通りあるので合計 $3$ 通りを出力します。Hintこの問題には部分点が設定されています。$N \\le 2000$ を満たすデータセット $1$ にすべて正解すると、$30$ 点が得られます。 追加制約のないデータセット $2$ にすべて正解すると、上記のデータセットに加えてさらに $70$ 点が得られ、全体で $100$ 点が得られます。Description in Chinese给出由$0 - 9$数字构成的字符串$S$。对某个字符串$X$来说，如果$X=$”$25$”或$X=$”$2525$”或$X=$”$252525$”$\\cdots \\cdots$，$X$像这样由”$25$”重复多次组成，那么就称$X$为niconico字符串。例如”$25$”或”$252525$”就是niconico字符串，而”$123$”或”$225$”不是niconico字符串。你的任务是，对于字符串$S$，请回答出$S$中有多少个子串为niconico字符串。即使子串相同，但是如果子串在原串中位置不同，也要分别计入总数中。Solution我们可以先把连续的25都替换从一个字符，如a，然后我们找连续的25，每一段25都可以用组合数计算出niconico的数量。然后累加就可以了。坑：注意要开long long。Code","tags":["题解","洛谷","C++","字符串","计数","Atcoder"],"categories":["题解"]},{"title":"『模板』快速读入 & 输出模板","url":"/2019/12/11/『模板』快速读入 & 输出模板/","content":"Mainly在卡常（80pts to 100pts）的时候，快速读入 &amp; 输出非常有用，原理就是一位一位读入（输出）。快速读入：用法示例：快速输出：用法示例：超级输入优化：用法示例：超级输出优化：用法示例：","tags":["模板","卡常"],"categories":["模板"]},{"title":"『题解』LibreOJ6278 数列分块入门 2","url":"/2019/12/11/『题解』LibreOJ6278 数列分块入门 2/","content":"PortalPortal1: LibreOJDescription给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内小于某个值$n$的元素个数。Input第一行输入一个数字$n$。第二行输入$n$个数字，第$i$个数字为$a_i$，以空格隔开。接下来输入$n$行询问，每行输入四个数字$\\mathrm{opt}$、$l$、$r$、$c$，以空格隔开。若$\\mathrm{opt} = 0$，表示将位于$[l, r]$的之间的数字都加$c$。若$\\mathrm{opt} = 1$，表示询问$[l, r]$中，小于$c ^ 2$的数字的个数。Output对于每次询问，输出一行一个数字表示答案。Sample InputSample OutputHint对于$100\\%$的数据，$1 \\le n \\le 50000, -2^{31} \\le \\mathrm{others}$、$\\mathrm{ans} \\le 2^{31}-1$。Solution首先将数组分块，然后求出每一个块的最大以及最小值，修改是暴力修改边角料，整块的修改块的懒标记。查询时，边角料还是暴力处理，对于整块：如果这个块的最大值小于目标值，那么答案增加块的大小，也就是块里的每个元素都符合要求；如果这个块的最小值大于目标值，那么答案不变，也就是块里每个元素都不符合要求；否则暴力查询。CodeAttachment测试数据下载：https://www.lanzous.com/i575irc","tags":["题解","C++","线段树","分块","LibreOJ"],"categories":["题解"]},{"title":"『题解』LibreOJ6277 数列分块入门 1","url":"/2019/12/11/『题解』LibreOJ6277 数列分块入门 1/","content":"PortalPortal1: LibreOJDescription给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，单点查值。Input第一行输入一个数字$n$。第二行输入$n$个数字，第$i$个数字为$a_i$，以空格隔开。接下来输入$n$行询问，每行输入四个数字$opt$、$l$、$r$、$c$，以空格隔开。若$\\texttt{opt = 0}$，表示将位于$[l,r]$的之间的数字都加$c$。若$\\texttt{opt = 1}$，表示询问$a_i$的值（$l$和$c$忽略）。Output对于每次询问，输出一行一个数字表示答案。Sample InputOutputHint对于$100\\%$的数据，$1 \\le n \\le 50000, -2^{31} \\le others, ans \\le 2^{31} - 1$。Solution分块，先将序列分成$\\sqrt{n}$块，区间加法时，整块左右的边角料暴力处理，整的块来更新懒标记。单点求值时，只要把自己的值与它所在的块的懒标记加起来就可以了。CodeAttachment测试数据下载：https://www.lanzous.com/i51c8of","tags":["题解","C++","线段树","分块","LibreOJ"],"categories":["题解"]},{"title":"『工具』对拍器","url":"/2019/12/11/『工具』对拍器/","content":"我们有一个非常好的方法来检验一个算法是否正确，我们可以先打一个暴力（绝对正确的代码），再写一个数据生的工具。我们可以将暴力的程序与你写的算法进行对拍。这样就能比较准确地知道你写的算法的正确性了。Windows下的对拍命令（.bat文件）：无文件输入输出版本：有文件输入输出版本：","tags":["工具","终端","命令"],"categories":["工具"]},{"title":"『题解』BZOJ2226 [Spoj 5971] LCMSum","url":"/2019/12/11/『题解』BZOJ2226 [Spoj 5971] LCMSum/","content":"PortalPortal: BZOJDescriptionGiven $n$, calculate the sum LCM(1,n) + LCM(2,n) + .. + LCM(n,n), where LCM(i,n) denotes the Least Common Multiple of the integers $i$ and $n$.InputThe first line contains $T$ the number of test cases. Each of the next $T$ lines contain an integer $n$.OutputOutput $T$ lines, one for each test case, containing the required sum.Sample InputSample OutputHint$1 \\le T \\le 300000$，$1 \\le n \\le 1000000$。Description in Chinese给定正整数$N$，求LCM(1, N) + LCM(2, N) + ... + LCM(N, N)。Solution题目中的式子可以化简为：$$\\begin{aligned} \\sum^{n}_{i = 1}{\\text{lcm}(i, n)} &amp; = \\sum^{n}_{i = 1}{\\frac{i \\times n}{\\gcd(i, n)}} \\\\ &amp; = n \\times \\sum^{n}_{i = 1}{\\frac{i}{\\gcd(i, n)}} \\\\ &amp; = n \\times \\sum_{d | n}\\sum_{i = 1}^{n}\\frac{i}{d} \\times (d == \\gcd(i, n)) \\\\ &amp; = \\frac{n}{d} \\times \\sum_{d | n}\\sum^{n}_{i = 1}d == \\gcd(i, n) \\end{aligned} \\\\\\ \\text{当}\\gcd(i, n) == 1 \\text{时，} \\gcd(n - i, n) == 1 (i, n - i \\ne 1) \\\\\\ \\therefore \\frac{n}{d} \\times \\sum_{d | n}\\sum^{n}_{i = 1}d == \\gcd(i, n) \\\\\\ = \\sum_{i = 1}^{n}i \\times (\\gcd(i, n) == 1)= n \\times \\frac{\\varphi(d)}{2}$$CodeAttachment测试数据下载：https://www.lanzous.com/i59jdri","tags":["题解","C++","BZOJ","数论，数学"],"categories":["题解"]},{"title":"「Luogu 3792」由乃与大母神原型和偶像崇拜","url":"/2019/12/11/「Luogu 3792」由乃与大母神原型和偶像崇拜/","content":"PortalPortal1: LuoguDescription给你一个序列$a$每次两个操作：修改$x$位置的值为$y$；查询区间$[l, r]$是否可以重排为值域上连续的一段。Input第一行两个数$n, m$；第二行$n$个数表示$a[i]$；后面m行每行三个数opt x y，或者opt l r，代表操作。Output如果可以，输出damushen；否则输出yuanxing。Sample InputSample OutputHint对于$30\\%$的数据，$n, m \\le 500$；对于$60\\%$的数据，$n, m \\le 100000$；对于$100\\%$的数据，$n, m \\le 500000$。值域$10 ^ 9$；时限：$2s$Solution这题很明显用线段树解决。题目要求的是更新一个点，查询一个区间是否能够一个等差数列，我们可以线段树维护最小值，最大值以及区间平方和，在查询的时候我们先询问出最小值与最大值，为等差数列的头与尾，那么我们可以算出这个数列的长度，与题目给出的是否一致，不一致就可以输出yuanxing。然后询问线段树的元素的平方和，与计算的头与尾构成的数列的平方和是否一致。但由于long long自然溢出问题，计算时用暴力解决即可。Code","tags":["题解","洛谷","C++","线段树","分块"],"categories":["题解"]},{"title":"「CF630C」Lucky Numbers","url":"/2019/12/11/「CF630C」Lucky Numbers/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionThe numbers of all offices in the new building of the Tax Office of IT City will have lucky numbers.Lucky number is a number that consists of digits $7$ and $8$ only. Find the maximum number of offices in the new building of the Tax Office given that a door-plate can hold a number not longer than $n$ digits.InputThe only line of input contains one integer $n (1 \\le n \\le 55)$ — the maximum length of a number that a door-plate can hold.OutputOutput one integer — the maximum number of offices, than can have unique lucky numbers not longer than $n$ digits.Sample InputSample OutputSolution题目要我们构造$1 \\sim n$位由$7, 8$的数的个数。我们先来找一找规律：位数为$1$时：有$7, 8$，共$2 \\times 2 ^ 0 = 2$种；位数为$2$时：有$77, 78, 87, 88$，共$2 \\times 2 ^ 1 = 4$种；位数为$3$时：有$777, 778, 787, 788, 877, 878, 887, 888$共$2 \\times 2 ^ 2 = 8$种；$\\cdots \\cdots$所以，位数是$n$的总个数是$2 \\times 2 ^ {n - 1}$；那么位数为$1 \\sim n$的总个数为$$\\begin{aligned} \\sum^{n}_{i = 1}{2 \\times 2 ^ {i - 1}} &amp; = 2 \\times \\sum^{n}_{i = 1}{2 ^ {i - 1}} \\\\\\ &amp; = 2 \\times (2 ^ {n} - 2) \\\\\\ &amp; = 2 ^ {n + 1} - 2\\end{aligned}$$于是就解决了。Code","tags":["题解","数学，数论","Codeforces","洛谷","C++"],"categories":["题解"]},{"title":"「Luogu 1349」广义斐波那契数列","url":"/2019/12/11/「Luogu 1349」广义斐波那契数列/","content":"PortalPortal1: LuoguDescription广义的斐波那契数列是指形如$an=p \\times a_{n-1}+q \\times a_{n-2}$的数列。今给定数列的两系数$p$和$q$，以及数列的最前两项$a_1$和$a_2$，另给出两个整数$n$和$m$，试求数列的第$n$项$a_n$除以$m$的余数。Input输入包含一行6个整数。依次是$p$,$q$,$a_1$,$a_2$,$n$,$m$，其中在$p$,$q$,$a_1$,$a_2$整数范围内，$n$和$m$在长整数范围内。Output输出包含一行一个整数，即$a_n$除以$m$的余数。Sample InputSample OutputHint数列第$10$项是$55$，除以$7$的余数为$6$。Solution基本斐波那契数列矩阵是$T = \\begin{bmatrix} 1 &amp; 1 \\\\\\ 1 &amp; 0 \\end{bmatrix}$；广义斐波那契数列矩阵是$F = \\begin{bmatrix} p &amp; 1 \\\\\\ q &amp; 0 \\end{bmatrix}$。那么要求的就是：$$\\begin{aligned} F_i &amp; = F_{i - 1} \\times T \\\\\\ &amp; = \\begin{bmatrix} f_{i - 1} &amp; f_{i - 2} \\\\\\ 0 &amp; 0 \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; 1 \\\\\\ 1 &amp; 0 \\end{bmatrix} \\\\\\ &amp; = \\begin{bmatrix} f_{i - 1} + f_{i - 2} &amp; f_{i - 1} \\\\\\ 0 &amp; 0 \\end{bmatrix} \\\\\\ &amp; = \\begin{bmatrix} f_i &amp; f_{i - 1} \\\\\\ 0 &amp; 0 \\end{bmatrix} \\end{aligned}$$然后就可以用矩阵快速幂来解决了。Code","tags":["题解","数学，数论","C++","矩阵","快速幂"],"categories":["题解"]},{"title":"「CF52C」Circular RMQ","url":"/2019/12/11/「CF52C」Circular RMQ/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionYou are given circular array $a_0, a_1, \\cdots, a_{n - 1}$. There are two types of operations with it:$\\textrm{inc}(lf, rg, v)$ — this operation increases each element on the segment $[lf, rg]$ (inclusively) by $v$;$\\textrm{rmq}(lf, rg)$ — this operation returns minimal value on the segment $[lf, rg]$ (inclusively).Assume segments to be circular, so if $n = 5$ and $lf = 3, rg = 1$, it means the index sequence: $3, 4, 0, 1$.Write program to process given sequence of operations.InputThe first line contains integer $n (1 \\le n \\le 200000)$. The next line contains initial state of the array: $a_0, a_1, \\cdots, a_{n - 1} ( -10^6 \\le ai \\le 10^6)$, $a_i$ are integer. The third line contains integer $m (0 \\le m \\le 200000)$, $m$ — the number of operartons. Next $m$ lines contain one operation each. If line contains two integer $lf, rg (0 \\le lf, rg \\le n - 1)$ it means rmq operation, it contains three integers $lf, rg, v (0 \\le lf, rg \\le n - 1; -10^6 \\le v \\le 10^6)$ — inc operation.OutputFor each rmq operation write result for it. Please, do not use %lld specificator to read or write $64$-bit integers in C++. It is preffered to use cout (also you may use %I64d).Sample InputSample OutputSolution我们可以用线段树来解决区间RMQ问题，我们在线段树上维护一个最小值与懒标记，这样问题就解决了。读入的时候我们可以判断后面一个字符是不是空格，可以直接在快速读入里判断，这样就可以判断出一行有三个数还是两个数。Code","tags":["题解","Codeforces","洛谷","C++","线段树","分块"],"categories":["题解"]},{"title":"「牛客练习赛53A」超越学姐爱字符串","url":"/2019/12/11/「牛客练习赛53A」超越学姐爱字符串/","content":"PortalPortal1: NowcoderDescription超越学姐非常喜欢自己的名字，以至于英文字母她只喜欢$\\textrm{“c”}$和$\\textrm{“y”}$。因此超越学姐喜欢只含有$\\textrm{“c”}$和$\\textrm{“y”}$的字符串，且字符串中不能出现两个连续的$\\textrm{“c”}$。请你求出有多少种长度为$n$的字符串是超越学姐喜欢的字符串。答案对$1e9 + 7$取模。Input输入一个整数$n$。$1 \\le n \\le 100000$。Output输出一个整数表示答案。Sample InputSample OutputSample Explain$\\textrm{cyy, cyc, yyy, yyc, ycy}$。Solution我们通过枚举可以发现当$n = 1$时，答案为$2$：c, y；当$n = 2$时，答案为$3$：cy, yc, yy；当$n = 3$时，答案为$5$：cyy, cyc, yyy, yyc, ycy；当$n = 4$时，答案为$8$：yyyy, yyyc, yycy, ycyy, cyyy, cycy, yccy, ycyc；当$n = 5$时，答案为$13$：yyyyy, yyyyc, yyycy, yycyy, ycyyy, cyyyy, yycyc, ycyyc, cyyyc, ycycy, cyycy, cycyy, cycyc；$\\cdots \\cdots$容易总结出规律：$\\textrm{f(i) = f(i - 1) + f(i - 2)}(x \\ge 3)$在写完代码时，还需要对于$n = 1$时特判。Code","tags":["C++","动态规划","找规律","Nowcoder"],"categories":["题解"]},{"title":"「Luogu 1412」经营与开发","url":"/2019/12/11/「Luogu 1412」经营与开发/","content":"PortalPortal1: LuoguDescription你驾驶着一台带有钻头（初始能力值$w$）的飞船，按既定路线依次飞过$n$个星球。星球笼统的分为$2$类：资源型和维修型。（$p$为钻头当前能力值）资源型：含矿物质量$\\rm a[i]$，若选择开采，则得到$a[i] \\times p$的金钱，之后钻头损耗k%，即$p = p \\times (1 - 0.01k)$维修型：维护费用$\\rm b[i]$，若选择维修，则支付$b[i] \\times p$的金钱，之后钻头修复c%，即$p = p \\times (1 + 0.01c)$注：维修后钻头的能力值可以超过初始值（你可以认为是翻修$+$升级）金钱可以透支。请作为舰长的你仔细抉择以最大化收入。Input第一行$4$个整数$n, k, c, w$。以下$n$行，每行$2$个整数$type, x$。$\\rm type$为$1$则代表其为资源型星球，$x$为其矿物质含量$\\rm a[i]$；$\\rm type$为$2$则代表其为维修型星球，$x$为其维护费用$\\rm b[i]$；Output一个实数（保留$2$位小数），表示最大的收入。Sample InputSample OutputHint【数据范围】对于$30\\%$的数据$n \\le 100$；另有$20\\%$的数据$n \\le 1000, k = 100$；对于$100\\%$的数据$n \\le 100000, 0 \\le k, c, w, a[i], b[i] \\le 100$；保证答案不超过$10^9$。Solution很容易想到是动态规划，按题目说的，我们分为两种情况，分别为$\\rm type = 1$和$\\rm type = 2$，但是如果直接顺序进行$\\rm dp$，发现存在后效性，无法直接确定答案，所以我们倒着来，转移方程分别为：当$type = 1$时：$\\rm dp[i] = \\max(dp[i + 1], a[i] + dp[i + 1] \\times (1 - 0.01 \\times k))$当$type = 2$时，$\\rm dp[i] = \\max(dp[i + 1], -a[i] + dp[i + 1] \\times (1 + 0.01 \\times c))$答案就是$\\rm dp[1]$。Code","tags":["题解","洛谷","C++","动态规划"],"categories":["题解"]},{"title":"『题解』洛谷P3376 【模板】网络最大流","url":"/2019/12/11/『题解』洛谷P3376 【模板】网络最大流/","content":"PortalPortal1：LuoguDescription如题，给出一个网络图，以及其源点和汇点，求出其网络最大流。Input第一行包含四个正整数$N,M,S,T$，分别表示点的个数，有向边的个数，源点序号，汇点序号。接下来$M$行每行包含三个正整数$u_i,v_i,w_i$，表示第$i$条有向边从$w_i$出发，到达$v_i$，边权为$w_i$（即该边最大流量为$w_i$）。Output一行，包含一个正整数，即为该网络的最大流。Sample InputSample OutputHint数据规模：对于$30\\%$的数据：$N \\leq 10,M \\leq 25$；对于$70\\%$的数据：$N \\leq 200,M \\leq 1000$；对于$100\\%$的数据：$N \\leq 10000,M \\leq 100000$。样例说明：题目中存在$3$条路径：$4 \\to 2 \\to 3$，该路线可通过$20$的流量$4 \\to 3$，可通过$20$的流量$4 \\to 2 \\to 1 \\to 3$，可通过$10$的流量（边$4 \\to 2$之前已经耗费了$20$的流量）故流量总计$20+20+10=50$，输出$50$。Solution模板题，求最大流。CodeEmonds Karp（EK）算法Dinic算法Improved Shortest Augmenting Path（ISAP）算法","tags":["题解","洛谷","C++","模板","网络流"],"categories":["题解"]},{"title":"『题解』洛谷P4016 负载平衡问题","url":"/2019/12/11/『题解』洛谷P4016 负载平衡问题/","content":"PortalPortal1：LuoguPortal2: LibreOJDescription$G$公司有$n$个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使$n$个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。Input文件的第$1$行中有$1$个正整数$n$，表示有$n$个仓库。第$2$行中有$n$个正整数，表示$n$个仓库的库存量。Output输出最少搬运量。Sample InputSample OutputHint对于$100\\%$的测试数据：$1 \\leq n \\leq 100$。Solution虽然说是网络流24题，其实贪心+排序就够了。CodeAttachment测试数据下载：https://www.lanzous.com/i3juukh","tags":["题解","洛谷","C++","LibreOJ","贪心","网络流","网络流24题"],"categories":["题解"]},{"title":"『题解』BZOJ1798 [AHOI2009]维护序列","url":"/2019/12/11/『题解』BZOJ1798 [AHOI2009]维护序列/","content":"PortalPortal1: BZOJPortal2: LuoguDescription老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。有长为$N$的数列，不妨设为$a_1, a_2, \\dots , a_N$。有如下三种操作形式：把数列中的一段数全部乘一个值;把数列中的一段数全部加一个值;询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模$P$的值。Input第一行两个整数$N$和$P$（$1 \\le P \\le 1000000000$）。第二行含有N个非负整数,从左到右依次为$a_1, a_2, \\dots , a_N$，（$0 \\le ai \\le 1000000000,1 \\le i \\le N$）。第三行有一个整数$M$，表示操作总数。从第四行开始每行描述一个操作，输入的操作有以下三种形式：操作$1$：1 t g c。表示把所有满足$t \\le i \\le g$的$a_i$改为$ai \\times c$（$1 \\le t \\le g \\le N, 0 \\le c \\le 1000000000$）。操作$2$： 2 t g c。表示把所有满足$t \\le i \\le g$的$a_i$改为$ai + c$（$1 \\le t \\le g \\le N, 0 \\le c \\le 1000000000$）。操作$3$： 3 t g。询问所有满足$t \\le i \\le g$的$a_i$的和模$P$的值（$1 \\le t \\le g \\le N$）。同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。Output对每个操作$3$，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。Sample Input###Sample OutputSample Explain初始时数列为$(1, 2, 3, 4, 5, 6, 7)$。经过第$1$次操作后，数列为$(1, 10, 15, 20, 25, 6, 7)$。对第$2$次操作，和为$10 + 15 + 20 = 45$，模$43$的结果是$2$。经过第$3$次操作后，数列为$(1, 10, 24, 29, 34, 15, 16)$对第$4$次操作，和为$1 + 10 + 24 = 35$，模$43$的结果是$35$。对第$5$次操作，和为$29 + 34 + 15 + 16 = 94$,模$43$的结果是$8$。Hint数据编号NM110102100010003100010004100001000056000060000670000700007800008000089000090000910000010000010100000100000Solution线段树模板题，区间加法，区间乘法，区间求和。CodeAttachment测试数据下载：https://www.lanzous.com/i5180sh","tags":["题解","洛谷","C++","线段树","分块","BZOJ","AHOI"],"categories":["题解"]},{"title":"『题解』BZOJ1036 [ZJOI2008]树的统计","url":"/2019/12/11/『题解』BZOJ1036 [ZJOI2008]树的统计/","content":"PortalPortal1: BZOJPortal2: LuoguDescription一棵树上有$n$个节点，编号分别为$1$到$n$，每个节点都有一个权值$w$。我们将以下面的形式来要求你对这棵树完成一些操作：CHANGE u t： 把结点$u$的权值改为$t$；QMAX u v： 询问从点$u$到点$v$的路径上的节点的最大权值；QSUM u v： 询问从点$u$到点$v$的路径上的节点的权值和。注意：从点$u$到点$v$的路径上的节点包括$u$和$v$本身。Input输入文件的第一行为一个整数$n$，表示节点的个数。接下来$n – 1$行，每行$2$个整数$a$和$b$，表示节点$a$和节点$b$之间有一条边相连。接下来一行$n$个整数，第i个整数$w_i$表示节点$i$的权值。接下来$1$行，为一个整数$q$，表示操作的总数。接下来$q$行，每行一个操作，以CHANGE u t或者QMAX u v或者QSUM u v的形式给出。Output对于每个QMAX或者QSUM的操作，每行输出一个整数表示要求输出的结果。Sample InputSample OutputSolution同『题解』洛谷P3384 【模板】树链剖分。CodeAttachment测试数据下载：https://www.lanzous.com/i5182ne","tags":["题解","洛谷","C++","树链剖分","ZJOI","BZOJ"],"categories":["题解"]},{"title":"『题解』洛谷P3384 【模板】树链剖分","url":"/2019/12/11/『题解』洛谷P3384 【模板】树链剖分/","content":"PortalPortal1: LuoguDescription如题，已知一棵包含$N$个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：操作$1$： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上$z$；操作$2$： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和；操作$3$： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上$z$；操作$4$： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和。Input第一行包含$4$个正整数$N$、$M$、$R$、$P$，分别表示树的结点个数、操作个数、根节点序号和取模数（即所有的输出结果均对此取模）。接下来一行包含$N$个非负整数，分别依次表示各个节点上初始的数值。接下来$N - 1$行每行包含两个整数$x$、$y$，表示点$x$和点$y$之间连有一条边（保证无环且连通）接下来$M$行每行包含若干个正整数，每行表示一个操作，格式如下：操作$1$： 1 x y z操作$2$： 2 x y操作$3$： 3 x z操作$4$： 4 xOutput输出包含若干行，分别依次表示每个操作$2$或操作$4$所得的结果（对$P$取模）。Sample InputSample OutputSolution模板树链剖分题。一些概念：重儿子：在每一个非叶子结点的儿子中，以那个儿子结点为根的子树的结点数最多的儿子为该结点的重儿子；轻儿子：在非叶子，非重儿子结点；重边：一个父亲结点连结它的重儿子的边；轻边：非重边；重链：相邻重边连起来的，连接一条重儿子结点的链叫重链。dfs1的功能：求出每结点的深度；求出每个结点的父亲节点；求出每个非叶子结点的子树的大小；求出每个非叶子结点的重儿子的编号。dfs2的功能：处理每条链；标记每个结点的新编号；求出每个结点所在链的顶；把结点的初始值更新到新编号里。Code","tags":["题解","洛谷","C++","树链剖分","模板"],"categories":["题解"]},{"title":"『题解』UVa11324 The Largest Clique","url":"/2019/12/11/『题解』UVa11324 The Largest Clique/","content":"PortalPortal1：UVaPortal2：LuoguPortal3：VjudgeDescriptionGiven a directed graph $\\text{G}$, consider the following transformation.First, create a new graph $\\text{T(G)}$ to have the same vertex set as $\\text{G}$. Create a directed edge between two vertices u and v in $\\text{T(G)}$ if and only if there is a path between u and v in $\\text{G}$ that follows the directed edges only in the forward direction. This graph $\\text{T(G)}$ is often called the $\\text{transitive closure}$ of $\\text{G}$.We define a $\\text{clique}$ in a directed graph as a set of vertices $\\text{U}$ such that for any two vertices u and v in $\\text{U}$, there is a directed edge either from u to v or from v to u (or both). The size of a clique is the number of vertices in the clique.InputThe number of cases is given on the first line of input. Each test case describes a graph $\\text{G}$. It begins with a line of two integers $n$ and $m$, where $0 \\leq n \\leq 1000$ is the number of vertices of $\\text{G}$ and $0 \\leq m \\leq 50, 000$ is the number of directed edges of $\\text{G}$. The vertices of $\\text{G}$ are numbered from $1$ to $n$. The following $m$ lines contain two distinct integers $u$ and $v$ between $1$ and $n$ which define a directed edge from $u$ to $v$ in $\\text{G}$.OutputFor each test case, output a single integer that is the size of the largest clique in $\\text{T(G)}$.Sample InputSample OutputDescription in Chinese给你一张有向图$\\text{G}$，求一个结点数最大的结点集，使得该结点集中的任意两个结点 $u$ 和 $v$ 满足：要么 $u$ 可以达 $v$，要么 $v$ 可以达 $u$（$u$, $v$相互可达也行）。SolutionTarjan缩点$+$记忆化搜索。Code","tags":["题解","洛谷","C++","记忆化搜索","Tarjan","UVa"],"categories":["题解"]},{"title":"『题解』Codeforces10D LCIS","url":"/2019/12/11/『题解』Codeforces10D LCIS/","content":"Portal:Portal1: CodeforcesPortal2: LuoguDescriptionThis problem differs from one which was on the online contest.The sequence $a_1, a_2, \\cdots , a_n$ is called increasing, if $a_i &lt; a_{i + 1}$ for $i &lt; n$.The sequence $s_1, s_2, \\cdots , a_n$ is called the subsequence of the sequence $a_1, a_2, \\cdots , a_n$, if there exist such a set of indexes $1 \\le i_1 &lt; i_2 &lt; \\cdots &lt; i_k \\le n$ that $a_{i, j} = s_j$. In other words, the sequence $s$ can be derived from the sequence $a$ by crossing out some elements.You are given two sequences of integer numbers. You are to find their longest common increasing subsequence, i.e. an increasing sequence of maximum length that is the subsequence of both sequences.InputThe first line contains an integer $n (1 \\le n \\le 500)$ — the length of the first sequence. The second line contains $n$ space-separated integers from the range $[0, 10^9]$ — elements of the first sequence. The third line contains an integer $m (1 \\le m \\le 500)$ — the length of the second sequence. The fourth line contains m space-separated integers from the range $[0, 10^9]$ — elements of the second sequence.OutputIn the first line output $k$ — the length of the longest common increasing subsequence. In the second line output the subsequence itself. Separate the elements with a space. If there are several solutions, output any.Sample Input1Sample Output1Sample Input2Sample Output2Description in Chinese求两个序列的最长公共上升子序列。Solution用$\\texttt{f[i][j]}$表示$\\texttt{A}$与$\\texttt{B}$构成的以$b_j$为结尾的最长公共上升子序列的长度。动态转移方程为：$$f[i][j] = \\max_{k = 0}^{j - 1}{(f[i - 1][k] + 1)}, \\texttt{其中}B_k &lt; B_j$$而$k$这一维可以省去，在状态转移后记录最大符合要求的$f[k]$作为下一次的转移，正确性仍旧不变。所以，最后的时间复杂度为$O(n^2)$。Code","tags":["题解","Codeforces","洛谷","C++","LCIS","DP"],"categories":["题解"]},{"title":"『题解』Codeforces2A Winner","url":"/2019/12/11/『题解』Codeforces2A Winner/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionThe winner of the card game popular in Berland “Berlogging” is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line “$\\texttt{name score}$”, where name is a player’s name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to $m$) at the end of the game, than wins the one of them who scored at least $m$ points first. Initially each player has $0$ points. It’s guaranteed that at the end of the game at least one player has a positive number of points.InputThe first line contains an integer number $n(1 \\le n \\le 1000)$, $n$ is the number of rounds played. Then follow $n$ lines, containing the information about the rounds in “$\\texttt{name score}$” format in chronological order, where $\\texttt{name}$ is a string of lower-case Latin letters with the length from $1$ to $32$, and $\\texttt{score}$ is an integer number between $-1000$ and $1000$, inclusive.OutputPrint the name of the winner.Sample Input1Sample Output1Sample Input2Sample Output2Description in Chinese在Berland流行着纸牌游戏“Berlogging”，这个游戏的赢家是根据以下规则确定的：在每一轮中，玩家获得或失去一定数量的分数，在游戏过程中，分数被记录在“名称和得分”行中，其中名字是玩家的名字，得分是在这一轮中获得的分数。得分是负值意味着玩家失去了相应的分数。如果在比赛结束时只有一名玩家分数最多，他就是获胜者。如果两名或两名以上的玩家在比赛结束时都有最大的分数$m$，那么其中首先获得至少$m$分的玩家胜利。开始时，每个玩家都是$0$分。保证在比赛结束时至少有一个玩家的分数为正。Solution把每个人的得分存到$\\texttt{map}$里，然后求出最大得分，再寻找最先到达最大得分的人，即为获胜者。Code","tags":["题解","Codeforces","洛谷","C++","模拟"],"categories":["题解"]},{"title":"『题解』BZOJ3172 [TJOI2013]单词","url":"/2019/12/11/『题解』BZOJ3172 [TJOI2013]单词/","content":"PortalPortal1：BZOJPortal2：LuoguDescription某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。Input第一个整数$n$，表示有多少个单词，接下来$n$行每行一个单词。每个单词由小写字母组成，$n \\leq 200$，单词长度不超过$10^{6}$。Output输出$n$个整数，第$i$行的数字表示第$i$个单词在文章中出现了多少次。Sample InputSample OutputSolution暴力出奇迹！CodeAttachment测试数据下载：https://www.lanzous.com/i3jv07a","tags":["题解","洛谷","C++","字符串","BZOJ","枚举","AC自动机","TJOI"],"categories":["题解"]},{"title":"『题解』Coderforces142B Help General","url":"/2019/12/11/『题解』Coderforces142B Help General/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionOnce upon a time in the Kingdom of Far Far Away lived Sir Lancelot, the chief Royal General. He was very proud of his men and he liked to invite the King to come and watch drill exercises which demonstrated the fighting techniques and tactics of the squad he was in charge of. But time went by and one day Sir Lancelot had a major argument with the Fairy Godmother (there were rumors that the argument occurred after the general spoke badly of the Godmother’s flying techniques. That seemed to hurt the Fairy Godmother very deeply).As the result of the argument, the Godmother put a rather strange curse upon the general. It sounded all complicated and quite harmless: “If the squared distance between some two soldiers equals to $5$, then those soldiers will conflict with each other!”The drill exercises are held on a rectangular n × m field, split into nm square $1 \\times 1$ segments for each soldier. Thus, the square of the distance between the soldiers that stand on squares $(x1, y1)$ and $(x2, y2)$ equals exactly $(x1 - x2)^2 + (y1 - y2)^2$. Now not all nm squad soldiers can participate in the drill exercises as it was before the Fairy Godmother’s curse. Unless, of course, the general wants the soldiers to fight with each other or even worse… For example, if he puts a soldier in the square $(2, 2)$, then he cannot put soldiers in the squares $(1, 4)$, $(3, 4)$, $(4, 1)$ and $(4, 3)$ — each of them will conflict with the soldier in the square $(2, 2)$.Your task is to help the general. You are given the size of the drill exercise field. You are asked to calculate the maximum number of soldiers that can be simultaneously positioned on this field, so that no two soldiers fall under the Fairy Godmother’s curse.InputThe single line contains space-separated integers $n$ and $m (1 \\le n, m \\le 1000)$ that represent the size of the drill exercise field.OutputPrint the desired maximum number of warriors.Sample Input1Sample Output1Sample Input2Sample Output2Sample ExplainIn the first sample test Sir Lancelot can place his $4$ soldiers on the $2 \\times 4$ court as follows (the soldiers’ locations are marked with gray circles on the scheme):In the second sample test he can place $6$ soldiers on the $3 \\times 4$ site in the following manner:Description in Chinese在$n \\times m$的国际象棋棋盘上放尽可能多的马，让它们互不攻击，求出最多可以放的马的数量。Solution不妨令$n &lt; m$。然后，我们分情况来考虑：当$n = 1$时，无论马放在哪里，都不能攻击到其它任何马，所以答案就是$m$；当$n = 2$时，我们可以这么放：（1表示放，0表示不放）这样能保证马互不攻击，因为这是国际象棋，不存在马因特殊情况不能攻击另一匹马。箭头表示攻击到的点。当$n &gt; 2$时，我们可以按国际象棋的棋盘放，这样马也不能互相攻击。Code","tags":["题解","Codeforces","洛谷","C++","贪心","构造"],"categories":["题解"]},{"title":"『题解』Codeforces220B Little Elephant and Array","url":"/2019/12/11/『题解』Codeforces220B Little Elephant and Array/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionThe Little Elephant loves playing with arrays. He has array $a$, consisting of $n$ positive integers, indexed from $1$ to $n$. Let’s denote the number with index $i$ as $a_i$.Additionally the Little Elephant has $m$ queries to the array, each query is characterised by a pair of integers $l_j$ and $r_j (1 \\le l_j \\le r_j \\le n)$. For each query $l_j, r_j$ the Little Elephant has to count, how many numbers $x$ exist, such that number $x$ occurs exactly $x$ times among numbers $a_{l_j}, a_{l_j + 1}, \\cdots , a_{r_j}$.Help the Little Elephant to count the answers to all queries.InputThe first line contains two space-separated integers $n$ and $m (1 \\le n, m \\le 105)$ - the size of array a and the number of queries to it. The next line contains $n$ space-separated positive integers $a_1, a_2, \\cdots , a_n (1 \\le ai \\le 10^9)$. Next $m$ lines contain descriptions of queries, one per line. The $j$-th of these lines contains the description of the $j$-th query as two space-separated integers $l_j$ and $r_j (1 \\le l_j \\le r_j \\le n)$.OutputIn $m$ lines print $m$ integers - the answers to the queries. The $j$-th line should contain the answer to the $j$-th query.Sample Input1Sample OutputDescription in Chinese小象喜欢和数组玩。现在有一个数组$a$，含有$n$个正整数，记第$i$个数为$a_i$。现在有$m$个询问，每个询问包含两个正整数$l_j$和$r_j (1 \\le l_j \\le r_j \\le n)$，小象想知道在$a_{l_j}到$a_{r_j}$之中有多少个数$x$，其出现次数也为$x$。Solution我们先看题目，发现只有查询，没有修改，所以可以用普通的莫队解决。题目中的$a_i$的范围是$\\in [1, 10^9]$，而数的总数的范围是$\\in [1, 10^5]$，所以当这个数大于$10^5$了，这个数就不可能为所求的$x$忽略这个数后就不用进行离散化了。Code","tags":["题解","Codeforces","洛谷","C++","莫队"],"categories":["题解"]},{"title":"『题解』洛谷P2357 守墓人","url":"/2019/12/11/『题解』洛谷P2357 守墓人/","content":"PortalPortal1: LuoguDescription在一个荒凉的墓地上有一个令人尊敬的守墓人，他看守的墓地从来没有被盗过， 所以人们很放心的把自己的先人的墓安顿在他那守墓人能看好这片墓地是必然而不是偶然…..因为….守墓人懂风水。他把墓地分为主要墓碑和次要墓碑，主要墓碑只能有$1$个， 守墓人把他记为$1$号， 而次要墓碑有$n-1$个，守墓人将之编号为$2, 3 \\dots n$，所以构成了一个有$n$个墓碑的墓地。而每个墓碑有一个初始的风水值，这些风水值决定了墓地的风水的好坏，所以守墓人需要经常来查询这些墓碑。善于运用风水的守墓人，通过一次次逆天改命，使得自己拥有了无限寿命，没人知道他活了多久。这天，你幸运的拜访到了他，他要求你和他共同见证接下来几年他的战果，但不过他每次统计风水值之和都需要你来帮他计算，算错了他会要你命QAQ，风水也不是不可变，除非遭遇特殊情况，已知在接下来的$2147483647$年里，会有$n$次灾难，守墓人会有几个操作：将$[l,r]$这个区间所有的墓碑的风水值增加$k$；将主墓碑的风水值增加$k$；将主墓碑的风水值减少$k$；统计$[l,r]$这个区间所有的墓碑的风水值之和；求主墓碑的风水值。上面也说了，很多人会把先人的墓安居在这里，而且守墓人活了很多世纪，墓碑的数量会多的你不敢相信，守墓人和善的邀请你帮他完成这些操作，要不然哪天你的旅馆爆炸了，天上下刀子$\\dots \\dots$为了活命，还是帮他吧。Input第一行，两个正整数$n, f$表示共有$n$块墓碑，并且在接下来的$2147483647$年里，会有$f$次世界末日；第二行，$n$个正整数，表示第$i$块墓碑的风水值；接下来$f$行，每行都会有一个针对世界末日的解决方案，如题所述，标记同题。Output输出会有若干行，对$4$和$5$的提问做出回答。Sample InputSample OutputHint$20\\%$的数据满足：$1 \\le n \\le 100$；$50\\%$的数据满足：$1 \\le n \\le 6000$；$100\\%$的数据满足：$1 \\le n, f \\le 2 \\times 10^{5}$；Solution这题树状数组。用c1[]来维护和，c2[]来维护积。对于询问$[x, y]$区间，可以用$\\mathrm{query}(y) - \\mathrm{query}(x - 1) + (x == 1) \\times \\text{主墓碑的风水值}$来求值，其中$\\mathrm{query}(y) - \\mathrm{query}(x - 1)$类似于前缀和，$(x == 1) \\times \\text{主墓碑的风水值}$表示$[x, y]$区间包不包含主墓碑，如果包含则加上主墓碑单独维护的。其中主墓碑需要单独维护。Code","tags":["题解","洛谷","C++","线段树","分块","树状数组"],"categories":["题解"]},{"title":"『题解』Codeforces888A Local Extrema","url":"/2019/12/11/『题解』Codeforces888A Local Extrema/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionYou are given an array $a$. Some element of this array $a_i$ is a local minimum iff it is strictly less than both of its neighbours (that is, $a_i &lt; a_i - 1$ and $a_i &lt; a_i + 1$). Also the element can be called local maximum iff it is strictly greater than its neighbours (that is, $a_i &gt; a_i - 1$ and $a_i &gt; a_i + 1$). Since a1 and an have only one neighbour each, they are neither local minima nor local maxima.An element is called a local extremum iff it is either local maximum or local minimum. Your task is to calculate the number of local extrema in the given array.InputThe first line contains one integer $n (1 \\le n \\le 1000)$ — the number of elements in array $a$.The second line contains $n$ integers $a1, a2,\\cdots , a_n (1 \\le a_i \\le 1000)$ — the elements of array $a$.OutputPrint the number of local extrema in the given array.Sample Input1Sample Output1Sample Input2Sample Output3Solution题目怎么说我们怎么做就可以了，循环直接从$2 \\to n - 1$进行枚举。Code","tags":["题解"],"categories":["题解"]},{"title":"『题解』Codeforces656E Out of Controls","url":"/2019/12/11/『题解』Codeforces656E Out of Controls/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionYou are given a complete undirected graph. For each pair of vertices you are given the length of the edge that connects them. Find the shortest paths between each pair of vertices in the graph and return the length of the longest of them.InputThe first line of the input contains a single integer $N (3 \\le N \\le 10)$.The following $N$ lines each contain $N$ space-separated integers. jth integer in ith line aij is the length of the edge that connects vertices $i$ and $j$. $a_{ij} = a_{ji}, a_{ii} = 0, 1 \\le a_{ij} \\le 100$ for $i \\ne j$.OutputOutput the maximum length of the shortest path between any pair of vertices in the graph.Sample Input1Sample Output1Sample Input2Sample Output2HintYou’re running short of keywords, so you can’t use some of them:Solution这题的$n$最大只有$10$，求的是两点见的最大的最短路，我们直接用Floyd解决。但这是一道愚人节的题，题目规定我们不能使用一些语法，我们直接可以用这样的形式解决：注意，把for改为大写还是会判错。Code","tags":["题解","Codeforces","洛谷","C++","最短路","Floyd"],"categories":["题解"]},{"title":"『题解』洛谷P5436 【XR-2】缘分","url":"/2019/12/11/『题解』洛谷P5436 【XR-2】缘分/","content":"PortalPortal1：LuoguDescription一禅希望知道他和师父之间的缘分大小。可是如何才能知道呢？一禅想了个办法，他先和师父约定一个正整数$n$，接着他们各自在心里想一个不超过$n$的正整数。一禅认为，他和师父心里想的这两个数的最小公倍数越大，则意味着他和师父之间的缘分越大。师父觉得这个办法很合适，不过他想知道这两个数的最小公倍数最大会是多少。师父的数学不太好，于是问一禅。一禅也觉得这个问题很困难，他希望你能告诉他答案。Input第一行一个正整数$T$，表示数据组数。接下来的$T$行，每行一个正整数$n$，表示一禅和师父约定的正整数。Output对每组数据，一行一个正整数，表示答案。Sample InputSample OutputSolution首先，$\\gcd(x, x - 1) = 1$，所以在$n$范围内，最小公倍数最大的一定是$\\mathrm{lcm}(n, n - 1) = n \\times (n - 1)$，于是答案就是$n \\times (n - 1)$。特殊地，当$n = 1$时，因为$n - 1 = 0$，所以最大只能是$\\mathrm{lcm}(1, 1) = 1$。Code","tags":["题解","洛谷","C++","数论，数学"],"categories":["题解"]},{"title":"『题解』洛谷P4936 Agent1","url":"/2019/12/11/『题解』洛谷P4936 Agent1/","content":"PortalPortal: LuoguDescription某地的ENLIGHTENED总部有$N$个Agent，每个Agent的能力值互不相同，现在ENLIGHTENED行动指挥想要派出$A, B$两队Agent去参加XM大战。但是参加大战的两个队伍要满足两个要求：$A$队中能力最大的Agent的能力值要小于$B$队能力最弱的Agent的能力值。$A, B$两队都要有人参战。并不一定所有的Agent都要去参加XM大战的，心急的ENLIGHTENED行动指挥想知道有多少种安排Agent参加大战的方案。由于答案可能很大，所以只需要你求出答案模$(10 ^ 9 + 7)$的值就可以了。Input输入仅一行，为一个整数$N$。Output输出答案模$(10 ^ 9 + 7)$的值。Sample Input1Sample Output1Sample Input2Sample Output2Solution根据题意，我们要取两组数，使$A$组的最大值小于$B$组的最小值，那么我们在一个有序的数列（不妨设为$1, 2, 3, \\cdots , n$）里，我们可以取一个数$p$，表示分界线（不妨把它放在$A$组），$A$组的取数范围就是$p$以及$p$左边的所有数，$B$组的取数范围就是$p$右边的所有数，因此当$p = i$时$A$组取数的方案总数就是$2 ^ {i - 1}$（前面的每个数要么取，要么不取），而$B$组取数的方案数就是$2 ^ {n - i} - 1$（为什么要减$1$，因为不允许$B$队没有人参战，而我们把$p$归入$A$队，因此$A$组不会空）。我们用代数的形式表示出来：$$\\begin{aligned} \\text{答案} &amp; = \\sum^{n}_{i = 1}{2 ^ {i - 1} \\times (2 ^ {n - i} - 1)} \\\\ &amp; = \\sum^{n}_{i = 1}{2 ^ {n - 1} - 2^{i - 1}} \\\\ &amp; = n \\times 2 ^ {n - 1} - \\sum^{n}_{i = 1}{2 ^ {i - 1}} \\\\ &amp; = n \\times 2 ^ {n - 1} -\\sum^{n - 1}_{i = 0}{2 ^ i} \\\\ &amp; = n \\times 2 ^ {n - 1} - (2 ^ 0 + \\sum^{n - 1}_{i = 1}{2 ^ i}) \\\\ &amp; = n \\times 2 ^ {n - 1} - (1 + 2 ^ n - 2) \\\\ &amp; = n \\times 2 ^ {n - 1} - 2^ n + 1 \\\\ &amp; = n \\times 2 ^ {n - 1} - 2 \\times 2 ^ {n - 1} + 1 \\\\ &amp; = (n - 2) \\times 2 ^ {n - 1} + 1 \\end{aligned}​$$于是我们就可以直接通过快速幂直接求出答案了。Code","tags":["题解","洛谷","C++","快速幂","数论，数学"],"categories":["题解"]},{"title":"『题解』洛谷P3958 奶酪","url":"/2019/12/11/『题解』洛谷P3958 奶酪/","content":"PortalPortal1: LuoguPortal2: LibreOJPortal3: VijosDescription现有一块大奶酪，它的高度为$h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为$z = 0$，奶酪的上表面为$z = h$。现在，奶酪的下表面有一只小老鼠Jerry，它知道奶酪中所有空洞的球心所在的坐 标。如果两个空洞相切或是相交，则Jerry可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry则可以从空洞跑到奶酪上表面。位于奶酪下表面的Jerry想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?空间内两点$P_1(x_1, y_1, z_1)$、$P_2(x_2, y_2, z_2)$的距离公式如下：$$\\operatorname{dist}(P_1, P_2) = \\sqrt{(x_1 - x_2) ^ 2 + (y_1 - y_2) ^ 2 + (z_1 - z_2) ^ 2}$$Input每个输入文件包含多组数据。的第一行，包含一个正整数$T$，代表该输入文件中所含的数据组数。接下来是$T$组数据，每组数据的格式如下：第一行包含三个正整数$n, h$和$r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。接下来的$n$行，每行包含三个整数$x, y, z$，两个数之间以一个空格分开，表示空 洞球心坐标为$(x, y, z)$。Output$T$行，分别对应$T$组数据的答案，如果在第$i$组数据中，Jerry能从下表面跑到上表面，则输出Yes，如果不能，则输出No（均不包含引号）。Sample InputSample OutputSample ExplainHint数据规模与约定：对于$20\\%$的数据，$n = 1, 1 \\le h, r \\le 10,000$，坐标的绝对值不超过$10,000$；对于$40\\%$的数据，$1 \\le n \\le 8, 1 \\le h, r \\le 10,000$，坐标的绝对值不超过$10,000$。对于$80\\%$的数据，$1 \\le n \\le 1,000, 1 \\le h , r \\le 10,000$，坐标的绝对值不超过$10,000$。对于$100\\%$的数据，$1 \\le n \\le 1,000, 1 \\le h , r \\le 1,000,000,000,T \\le 20$，坐标的 绝对值不超过$1,000,000,000$。Solution这题并查集。CodeAttachment测试数据下载：https://www.lanzous.com/i5gntle","tags":["题解","洛谷","C++","并查集","NOIP","LibreOJ"],"categories":["题解"]},{"title":"『题解』洛谷P2296 寻找道路","url":"/2019/12/11/『题解』洛谷P2296 寻找道路/","content":"PortalPortal1: LuoguPortal2: LibreOJDescription在有向图$\\mathrm G$中，每条边的长度均为$1$，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：路径上的所有点的出边所指向的点都直接或间接与终点连通。在满足条件$1$的情况下使路径最短。注意：图$\\mathrm G$中可能存在重边和自环，题目保证终点没有出边。 请你输出符合条件的路径的长度。Input第一行有两个用一个空格隔开的整数$n$和$m$，表示图有$n$个点和$m$条边。接下来的$m$行每行$2$个整数$x, y$，之间用一个空格隔开，表示有一条边从点$x$指向点$y$。最后一行有两个用一个空格隔开的整数$s, t$，表示起点为$s$，终点为$t$。Output输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出$-1$。Sample Input1Sample Output1Sample Input2Sample Output2Solution我们先看一个例子：不妨令起点为$1$，终点为$3$。这个例子的答案是$3$，路径是$1 \\to 4 \\to 5 \\to 3$。我们可以先检验出每一个点是否能到终点。可以从终点出发，按照反向边走一遍，然后把走不到的点以及它的入边连的点都删除，像这样：最后在跑一边$bfs$序，求出最短路就可以了。CodeAttachment测试数据下载：https://www.lanzous.com/i5qa0pg","tags":["题解","洛谷","C++","图论","NOIP","LibreOJ","搜索"],"categories":["题解"]},{"title":"『题解』洛谷P2170 选学霸","url":"/2019/12/11/『题解』洛谷P2170 选学霸/","content":"PortalPortal1: LuoguDescription老师想从$N$名学生中选$M$人当学霸，但有$K$对人实力相当，如果实力相当的人中，一部分被选上，另一部分没有，同学们就会抗议。所以老师想请你帮他求出他该选多少学霸，才能既不让同学们抗议，又与原来的$M$尽可能接近。Input第一行，三个正整数$N, M, K$。第$2$至$K$行，每行$2$个数，表示一对实力相当的人的编号（编号为$1 \\cdots N$）。Output一行，表示既不让同学们抗议，又与原来的$M$尽可能接近的选出学霸的数目。（如果有两种方案与$M$的差的绝对值相等，选较小的一种）Sample InputSample OutputHint对于$100\\%$的数据$N, P \\le 20000$。Solution这题如果选了一个人，那么与他实力相当的人也要选上。所以我们可以把会产生连锁反应的人都捆起来。不难想到用并查集。然后我们把一捆一捆的总价值记录下来，做一遍01背包就好了。Code","tags":["题解","洛谷","C++","并查集","背包"],"categories":["题解"]},{"title":"『题解』洛谷P1993 小K的农场","url":"/2019/12/11/『题解』洛谷P1993 小K的农场/","content":"PortalPortal1: LuoguDescription小$K$在$\\mathrm MC$里面建立很多很多的农场，总共$n$个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共$m$个），以下列三种形式描述：农场$a$比农场$b$至少多种植了$c$个单位的作物，农场$a$比农场$b$至多多种植了$c$个单位的作物，农场$a$与农场$b$种植的作物数一样多。但是，由于小$K$的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。Input第一行包括两个整数$n$和$m$，分别表示农场数目和小$K$记忆中的信息数目。接下来$m$行：如果每行的第一个数是$1$，接下来有$3$个整数$a, b, c$，表示农场$a$比农场$b$至少多种植了$c$个单位的作物。如果每行的第一个数是$2$，接下来有$3$个整数$a, b, c$，表示农场$a$比农场$b$至多多种植了$c$个单位的作物。如果每行的第一个数是$3$，接下来有$2$个整数$a, b$，表示农场$a$种植的的数量和$b$一样多。Output如果存在某种情况与小$K$的记忆吻合，输出Yes，否则输出No。Sample InputSample OutputHint对于$100\\%$的数据保证：$1 \\le n, m, a, b, c \\le 10000$。Solution我们用$\\mathrm{s[i]}$表示$i$农场的作物数量，那么题目中的条件我们可以表示为：$s[a] \\ge s[b] + c$$s[b] \\ge s[a] - c$$s[b] = s[a]$因为我们如果想让这道题用差分约束做，要把所有的约束条件都改为$\\le$或者$\\ge$的形式，但是此题的所有农场的做作物数都不能为负数，所以必须要用最长路解决。因此，我们可以改为：$s[a] \\ge s[b] + c$$s[b] \\ge s[a] - c$$s[a] \\ge s[b] + 0$$s[b] \\ge s[a] + 0$$s[i] \\ge 0$然后我们开始建边：对于题目给出的$a, b, c$$b \\to a$建一条权值为$c$的边；$a \\to b$建一条权值为$-c$的边；$a \\to b$建一条权值为$0$的边；$b \\to a$键一条权值为$0$的边；最后在$0 \\to i, i \\in [1, n]$建权值为$0$的边。建完之后用$\\mathrm{SPFA}$跑一遍最长路，顺便判断环就可以了。Code","tags":["题解","洛谷","C++","图论","差分约束","最长路"],"categories":["题解"]},{"title":"『题解』洛谷P1891 疯狂LCM","url":"/2019/12/11/『题解』洛谷P1891 疯狂LCM/","content":"PortalPortal: LuoguDescription众所周知，czmppppp是数学大神犇。一天，他给众蒟蒻们出了一道数论题，蒟蒻们都惊呆了。。。给定正整数$N$，求LCM(1, N) + LCM(2, N) + ... + LCM(N, N)。Input第一行一个数$T$，表示有$T$组数据。对于每组数据，一行，一个正整数$N$。Output$T$行，每行为对应答案。Sample InputSample OutputHint对于$30\\%$的数据，$1 \\le T \\le 5$，$1 \\le N \\le 100000$；对于$100\\%$的数据，$1 \\le T \\le 300000$，$1 \\le N \\le 1000000$。Solution题目中的式子可以化简为：$$\\begin{aligned} \\sum^{n}_{i = 1}{\\text{lcm}(i, n)} &amp; = \\sum^{n}_{i = 1}{\\frac{i \\times n}{\\gcd(i, n)}} \\\\ &amp; = n \\times \\sum^{n}_{i = 1}{\\frac{i}{\\gcd(i, n)}} \\\\ &amp; = n \\times \\sum_{d | n}\\sum_{i = 1}^{n}\\frac{i}{d} \\times (d == \\gcd(i, n)) \\\\ &amp; = \\frac{n}{d} \\times \\sum_{d | n}\\sum^{n}_{i = 1}d == \\gcd(i, n) \\end{aligned} \\\\\\ \\text{当}\\gcd(i, n) == 1 \\text{时，} \\gcd(n - i, n) == 1 (i, n - i \\ne 1) \\\\ \\therefore \\frac{n}{d} \\times \\sum_{d | n}\\sum^{n}_{i = 1}d == \\gcd(i, n) \\\\ = \\sum_{i = 1}^{n}i \\times (\\gcd(i, n) == 1)= n \\times \\frac{\\varphi(d)}{2}$$Code","tags":["题解","洛谷","C++","数论，数学"],"categories":["题解"]},{"title":"『题解』洛谷P1351 联合权值","url":"/2019/12/11/『题解』洛谷P1351 联合权值/","content":"PortalPortal1: LuoguPortal2: LibreOJDescription无向连通图$\\mathrm G$有$n$个点，$n - 1$条边。点从$1$到$n$依次编号，编号为$i$的点的权值为$W_i$ ，每条边的长度均为$1$。图上两点$(u, v)$的距离定义为$u$点到$v$点的最短距离。对于图$\\mathrm G$上的点对$(u, v)$，若它们的距离为$2$，则它们之间会产生$W_u \\times W_v$的联合权值。请问图$\\mathrm G$上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？Input第一行包含$1$个整数$n$。接下来$n - 1$行，每行包含2个用空格隔开的正整数$u, v$，表示编号为$u$和编号为$v$的点之间有边相连。最后$1$行，包含$n$个正整数，每两个正整数之间用一个空格隔开，其中第$i$个整数表示图$\\mathrm G$上编号为i的点的权值为$W_i$。Output输出共$1$行，包含$2$个整数，之间用一个空格隔开，依次为图$\\mathrm G$上联合权值的最大值和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对$10007$取余。Sample InputSample OutputSolution我们先看一下题目：无向连通图$\\mathrm G$有$n$个点，$n - 1$条边。不难发现题目给出的是一颗树。我们看一个例子：这个图的联合权值和为$W_2 \\times W_3 + W_4 \\times W_5 + W_4 \\times W_6 + W_5 \\times W_6 + W_7 \\times W_8$。不难发现，我们求的是对于每一棵子树的非根节点的所有子结点两两相乘的权值和。但是我们对每一棵子树都遍历一遍显然要超时。我们可以找到如下性质：$(a + b) ^ 2 = a ^ 2 + b ^ 2 + 2ab​ \\\\ (a + b + c) ^ 2 = a ^ 2 + b ^ 2 + c ^ 2 + 2ab+ 2ac + 2bc \\\\ (a + b + c + d) =  a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 + 2ab+ 2ac + 2ad + 2bc + 2bd + 2cd \\\\ \\cdots \\cdots$我们要求的就是平方项后面的一半。就是 $\\texttt{和的平方} - \\texttt{平方的和}$ 。统计最大值是只需要找出最大的两项，然后相乘就可以了。这样就这道题就解决了。CodeAttachment测试数据下载：https://www.lanzous.com/i5q1vdg","tags":["题解","洛谷","C++","图论","NOIP","LibreOJ"],"categories":["题解"]},{"title":"『题解』洛谷P1314 聪明的质监员","url":"/2019/12/11/『题解』洛谷P1314 聪明的质监员/","content":"Portal:Portal1: LuoguPortal2: LibreOJPortal3: VijosDescription小T是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有$n$个矿石，从$1$到$n$逐一编号，每个矿石都有自己的重量$w_i$以及价值$v_i$。检验矿产的流程是：给定$m$个区间$[L_i, R_i]$；选出一个参数$W$；对于一个区间$[L_i, R_i]$，计算矿石在这个区间上的检验值$Y_i$：$Y_i=\\sum_j1 \\times \\sum_j{v_j},\\ j\\in[L_i, R_i]$ 且 $w_j\\ge W,\\ j$是矿石编号这批矿产的检验结果$Y$为各个区间的检验值之和。即：$Y_1 + Y_2 +  \\cdots +Y_m$。若这批矿产的检验结果与所给标准值$S$相差太多，就需要再去检验另一批矿产。小T不想费时间去检验另一批矿产，所以他想通过调整参数$W$的值，让检验结果尽可能的靠近标准值$S$，即使得$S - Y$的绝对值最小。请你帮忙求出这个最小值。Input输入第一行包含三个整数$n$，$m$，$S$，分别表示矿石的个数、区间的个数和标准值；接下来的$n$行，每行$2$个整数，中间用空格隔开，第$i + 1$行表示$i$号矿石的重量$w_i$和价值$v_i$；接下来的$m$行，表示区间，每行$2$个整数，中间用空格隔开，第$i + n + 1$行表示区间$[L_i, R_i]$的两个端点$L_i$和$R_i$。注意：不同区间可能重合或相互重叠。Output一个整数，表示所求的最小值。Sample InputSample OutputSample Explain当$W$选$4$的时候，三个区间上检验值分别为$20, 5, 0$，这批矿产的检验结果为$25$，此时与标准值$S$相差最小为$10$。Hint对于$10\\%$的数据，有$1 \\le n, m \\le 10$；对于$30\\%$的数据，有$1 \\le n, m \\le 500$；对于$50\\%$的数据，有$1 \\le n, m \\le 5,000$；对于$70\\%$的数据，有$1 \\le n, m \\le 10,000$；对于$100\\%$的数据，有$1 \\le n, m \\le 200,000   ,0 &lt; w_i, v_i \\le 10^6,0 &lt; S \\le 10^{12},1 \\le L_i \\le R_i \\le n$。Solution这道题直接在$[0, \\max{w[i]}]$二分枚举$W$，对于每一个枚举出来的$w$，暴力计算每一个区间的检验值和，这里使用前缀和优化。CodeAttachment测试数据下载：https://www.lanzous.com/i527v3i","tags":["题解","洛谷","C++","二分","NOIP","LibreOJ"],"categories":["题解"]},{"title":"『题解』洛谷P1250 种树","url":"/2019/12/11/『题解』洛谷P1250 种树/","content":"PortalPortal1: LuoguDescription一条街的一边有几座房子。因为环保原因居民想要在路边种些树。路边的地区被分割成块，并被编号成$1 \\cdots N$。每个部分为一个单位尺寸大小并最多可种一棵树。每个居民想在门前种些树并指定了三个号码$B, E, T$。这三个数表示该居民想在$B$和$E$之间最少种T棵树。当然，$B \\le E$，居民必须记住在指定区不能种多于区域地块数的树，所以$T \\le E - B + 1$。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。Input第一行包含数据$N$，区域的个数$(0 &lt; N \\le 30000)$；第二行包含$H$，房子的数目$(0 &lt; H \\le 5000)$；下面的$H$行描述居民们的需要：B E T，$0 &lt; B \\le E \\le 30000，T \\le E - B + 1$。Output输出文件只有一行写有树的数目。Sample InputSample OutputSolution这题差分约束，我们用$\\mathrm{s[i]}$表示从第$1$号到第$i$号的树的数量的和（也就是前缀和）。那么题目中的约束条件就是：$s[E] - s[B - 1] \\ge T$因为事前缀和，所以还隐含了：$s[i] - s[i - 1] \\le 1$$s[i - 1] \\le s[i]$还有每个位置的树的数量都是大于$0$的数，所以还有：$s[i] \\le s[n + 1] + 0$（把$n + 1$号位置设置为超级源）整理可得：$s[B - 1] \\le s[E] - T$$s[i] \\le s[i - 1] + 1$$s[i - 1] \\le s[i] + 0$$s[i] \\le s[n + 1] + 0$然后跑最长路。这样，这道题就解决了。Code","tags":["题解","洛谷","C++","图论","差分约束","最长路"],"categories":["题解"]},{"title":"『题解』洛谷P1083 借教室","url":"/2019/12/11/『题解』洛谷P1083 借教室/","content":"PortalPortal1: LuoguPortal2: LibreOJPortal3: VijosDescription在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。面对海量租借教室的信息，我们自然希望编程解决这个问题。我们需要处理接下来n天的借教室信息，其中第$i$天学校有$r_i$个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为$d_j, s_j, t_j$，表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_j$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。Input第一行包含两个正整数$n, m$，表示天数和订单的数量。第二行包含$n$个正整数，其中第$i$个数为$r_i$，表示第$i$天可用于租借的教室数量。接下来有$m$行，每行包含三个正整数$d_j, s_j, t_j$，表示租借的数量，租借开始、结束分别在第几天。每行相邻的两个数之间均用一个空格隔开。天数与订单均用从$1$开始的整数编号。Output如果所有订单均可满足，则输出只有一行，包含一个整数$0$。否则（订单无法完全满足）输出两行，第一行输出一个负整数$-1$，第二行输出需要修改订单的申请人编号。Sample InputSample OutputHint对于$10\\%$的数据，有$1 \\le n, m \\le 10$；对于$30\\%$的数据，有$1 \\le n, m \\le 1000$；对于$70\\%$的数据，有$1 \\le n, m \\le 10^5$；对于$100\\%$的数据，有$1 \\le n, m \\le 10^6, 0 \\le r_i, d_j \\le 10^9, 1 \\le s_j \\le t_j \\le n$。Solution这题可以二分答案，先判断订单能否完全满足，然后开始二分。判断的过程可以用差分来解决，diff[i]为差分数组，在加入每一个借用段时，我们只要把头尾标记：在开头增加需要的教室数，在结尾减去它所需要的教室数即可。CodeAttachment测试数据下载：https://www.lanzous.com/i5gjpch","tags":["题解","洛谷","C++","差分","二分","NOIP","LibreOJ"],"categories":["题解"]},{"title":"『题解』洛谷P1072 Hankson 的趣味题","url":"/2019/12/11/『题解』洛谷P1072 Hankson 的趣味题/","content":"PortalPortal1: LuoguPortal2: LibreOJPortal3: VijosDescriptionHanks博士是BT（Bio-Tech，生物技术）领域的知名专家，他的儿子名叫Hankson。现在，刚刚放学回家的Hankson正在思考一个有趣的问题。今天在课堂上，老师讲解了如何求两个正整数$c_1$和$c_2$的最大公约数和最小公倍数。现在Hankson认为自己已经熟练地掌握了这些知识，他开始思考“求公约数”和“求公倍数”这类问题的一个逆问题，这个问题是这样的：已知正整数$a_0,a_1,b_0,b_1$，设某未知正整数$x$满足：$x$和$a_0$的最大公约数是$a_1$；$x$和$b_0$的最小公倍数是$b_1$。Hankson的“逆问题”就是求出满足条件的正整数$x$。但稍加思索之后，他发现这样的$x$并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的$x$的个数。请你帮助他编程求解这个问题。Input第一行为一个正整数$n$，表示有$n$组输入数据。接下来的$n$行每行一组输入数据，为四个正整数$a_0,a_1,b_0,b_1$，每两个整数之间用一个空格隔开。输入数据保证$a_0$能被$a_1$整除，$b_1能被$b_0$整除。Output共$n$行。每组输入数据的输出结果占一行，为一个整数。对于每组数据：若不存在这样的$x$，请输出$0$；若存在这样的$x$，请输出满足条件的$x$的个数。Sample InputSample OutputSolution$x$和$a_0$的最大公约数是$a_1$；$\\quad \\gcd(x, a_0) = a_1$$x$和$b_0$的最小公倍数是$b_1$。$\\quad \\mathrm{lcm}(x, b_0) = b_1 \\\\ \\Rightarrow b_1 = x \\times b_0 \\div \\gcd(x, b_0) \\\\ \\Rightarrow x \\times b_0 = b_1 \\times \\gcd(x, b_0) \\\\ \\Rightarrow x = \\frac{b_1}{b_0} \\times \\gcd(x, b_0)$我们需要证明：$\\gcd(\\frac{x}{a_1}, \\frac{a_0}{a_1}) = 1$，不妨使用反证法。令$\\gcd(\\frac{x}{a_1}, \\frac{a_0}{a_1}) \\ne 1$，它的值为$k$，$\\therefore \\frac{x}{a_1} = k \\times p, \\frac{a_0}{a_1} = k \\times q \\\\ \\therefore x = k \\times p \\times a_1, a_0 = k \\times q \\times a_1 \\\\ \\therefore \\gcd(x, a_0) \\ne k \\times a_1, \\text{与原命题不符} \\\\ \\therefore \\gcd(\\frac{x}{a_1}, \\frac{a_0}{a_1}) = 1$所以我们只要枚举$b_1$的因子个数。Code","tags":["题解","洛谷","C++","NOIP","LibreOJ","数论，数学"]},{"title":"『题解』洛谷P1063 能量项链","url":"/2019/12/11/『题解』洛谷P1063 能量项链/","content":"PortalPortal1：LuoguPortal2：LibreOJPortal3：VijosDescription在$Mars$星球上，每个$Mars$人都随身佩带着一串能量项链。在项链上有$N$颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是$Mars$人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为$m$，尾标记为$r$，后一颗能量珠的头标记为$r$，尾标记为$n$，则聚合后释放的能量为$m \\times r \\times n$（$Mars$单位），新产生的珠子的头标记为$m$，尾标记为$n$。需要时，$Mars$人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。例如：设$N=4$，$4$颗珠子的头标记与尾标记依次为$(2, 3) (3, 5) (5, 10) (10,2)$。我们用记号⊕表示两颗珠子的聚合操作，($j$⊕$k$)表示第$j,k$两颗珠子聚合后所释放的能量。则第$4$、$1$两颗珠子聚合后释放的能量为：$(4$⊕$1) = 10 \\times 2 \\times 3 = 60$。这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：$((4$⊕$1)$⊕$2)$⊕$3)=10 \\times 2 \\times 3 + 10 \\times 3 \\times 5+10 \\times 5 \\times 10 = 710$。Input第一行是一个正整数$n$（$4 \\le n \\le 100$），表示项链上珠子的个数。第二行是$n$个用空格隔开的正整数，所有的数均不超过$1000$。第$i$个数为第$i$颗珠子的头标记$(1 \\le i \\le n)$，当$i&lt;n$时，第$i$颗珠子的尾标记应该等于第$i + 1$颗珠子的头标记。第$n$颗珠子的尾标记应该等于第$1$颗珠子的头标记。至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。Output一个正整数$E(E \\le 2.1 × 10^{9})$，为一个最优聚合顺序所释放的总能量。Sample InputSample OutputSolution$\\texttt{dp[i][j]}​$表示以$\\texttt{a[i]}​$开头$\\texttt{a[j]}​$结尾的能量的最大值，可以推出动态转移方程：$dp[i][j]=\\max(f[i][j], dp[i][k]+dp[k][j]+a[i] \\times a[k] \\times a[j])$。CodeAttachment测试数据下载：https://www.lanzous.com/i3lgxeh","tags":["题解","洛谷","C++","动态规划","NOIP","LibreOJ"],"categories":["题解"]},{"title":"『题解』SP5971 LCMSUM - LCM Sum","url":"/2019/12/11/『题解』SP5971 LCMSUM - LCM Sum/","content":"PortalPortal1: Sphere Online JudgePortal2: LuoguDescriptionGiven $n$, calculate the sum LCM(1,n) + LCM(2,n) + .. + LCM(n,n), where LCM(i,n) denotes the Least Common Multiple of the integers $i$ and $n$.InputThe first line contains $T$ the number of test cases. Each of the next $T$ lines contain an integer $n$.OutputOutput $T$ lines, one for each test case, containing the required sum.Sample InputSample OutputHint$1 \\le T \\le 300000$，$1 \\le n \\le 1000000$。Description in Chinese给定正整数$N$，求LCM(1, N) + LCM(2, N) + ... + LCM(N, N)。Solution题目中的式子可以化简为：$$\\begin{aligned} \\sum^{n}_{i = 1}{\\text{lcm}(i, n)} &amp; = \\sum^{n}_{i = 1}{\\frac{i \\times n}{\\gcd(i, n)}} \\\\ &amp; = n \\times \\sum^{n}_{i = 1}{\\frac{i}{\\gcd(i, n)}} \\\\ &amp; = n \\times \\sum_{d | n}\\sum_{i = 1}^{n}\\frac{i}{d} \\times (d == \\gcd(i, n)) \\\\ &amp; = \\frac{n}{d} \\times \\sum_{d | n}\\sum^{n}_{i = 1}d == \\gcd(i, n) \\end{aligned} \\\\\\ \\text{当}\\gcd(i, n) == 1 \\text{时，} \\gcd(n - i, n) == 1 (i, n - i \\ne 1) \\\\ \\therefore \\frac{n}{d} \\times \\sum_{d | n}\\sum^{n}_{i = 1}d == \\gcd(i, n) \\\\ = \\sum_{i = 1}^{n}i \\times (\\gcd(i, n) == 1)= n \\times \\frac{\\varphi(d)}{2}$$Code","tags":["题解","洛谷","C++","数论，数学","SphereOJ"],"categories":["题解"]},{"title":"『题解』Coderforces352A Jeff and Digits","url":"/2019/12/11/『题解』Coderforces352A Jeff and Digits/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionJeff’s got n cards, each card contains either digit 0, or digit 5. Jeff can choose several cards and put them in a line so that he gets some number. What is the largest possible number divisible by 90 Jeff can make from the cards he’s got?Jeff must make the number without leading zero. At that, we assume that number 0 doesn’t contain any leading zeroes. Jeff doesn’t have to use all the cards.InputThe first line contains integer $n (1 \\le n \\le 103)$. The next line contains $n$ integers $a_1, a_2, \\cdots , a_n (a_i = 0 or a_i = 5)$. Number ai represents the digit that is written on the $i$-th card.OutputIn a single line print the answer to the problem - the maximum number, divisible by 90. If you can’t make any divisible by 90 number from the cards, print -1.Sample Input1Sample Output1Sample Input2Sample Output2Sample ExplainIn the first test you can make only one number that is a multiple of 90 - 0.In the second test you can make number $5555555550$, it is a multiple of 90.Description in ChineseJeff有一些数字卡片，上面为$0$或$5$。Jeff想用这些卡片组成一个数字，使这个数字可以被$90$整除并且尽可能的大。Solution先分解质因数：$90 = 9 \\times 10$为什么不分成$90 = 2 \\times 3^2 \\times 5$呢，因为$9$有自己的整除特性：各个数位之和被$9$整除。$10$的整除特性就不用说了。然后分类讨论：当$0$的个数为$0$，也就是没有$0$，我们就直接输出$-1$，因为无论怎么取都不能被$10$整除。当$5$的个数$\\le 9$，而且存在$0$时，我们只能构造出$9 | 0$（这里的$|$表示整除），比如样例$1$。当$5$的个数$\\ge 9$，而且存在$0$时，就可以构造能被$90$的数，比如样例$2$。我们可以把$5$的个数$\\div 9$取整后$\\times 9$就得到所要输出的$5$的个数了，这个数一定是最大的能被9整除的数，当然最后要把所有的$0$输出。Code","tags":["题解","Codeforces","洛谷","C++","数论，数学"],"categories":["题解"]},{"title":"『题解』Codeforces1143C Queen","url":"/2019/12/11/『题解』Codeforces1143C Queen/","content":"PortalPortal2: CodeforcesPortal2: LuoguDescriptionYou are given a rooted tree with vertices numerated from $1$ to $n$. A tree is a connected graph without cycles. A rooted tree has a special vertex named root.Ancestors of the vertex $i$ are all vertices on the path from the root to the vertex $i$, except the vertex $i$ itself. The parent of the vertex $i$ is the nearest to the vertex $i$ ancestor of $i$. Each vertex is a child of its parent. In the given tree the parent of the vertex $i$ is the vertex $p_i$. For the root, the value $p_i$ is $-1$.An example of a tree with $n=8$, the root is vertex $5$. The parent of the vertex $2$ is vertex $3$, the parent of the vertex $1$ is vertex $5$. The ancestors of the vertex $6$ are vertices $4$ and $5$, the ancestors of the vertex $7$ are vertices $8$, $3$ and $5$You noticed that some vertices do not respect others. In particular, if $c_i = 1$, then the vertex $i$ does not respect any of its ancestors, and if $c_i = 0$, it respects all of them.You decided to delete vertices from the tree one by one. On each step you select such a non-root vertex that it does not respect its parent and none of its children respects it. If there are several such vertices, you select the one with the smallest number. When you delete this vertex $v$, all children of $v$ become connected with the parent of $v$.Once there are no vertices matching the criteria for deletion, you stop the process. Print the order in which you will delete the vertices. Note that this order is unique.InputThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of vertices in the tree.The next $n$ lines describe the tree: the $i$-th line contains two integers $p_i$ and $c_i$ ($1 \\le p_i \\le n$, $0 \\le c_i \\le 1$), where $p_i$ is the parent of the vertex $i$, and $c_i = 0$, if the vertex $i$ respects its parents, and $c_i = 1$, if the vertex $i$ does not respect any of its parents. The root of the tree has $-1$ instead of the parent index, also, $c_i=0$ for the root. It is guaranteed that the values $p_i$ define a rooted tree with $n$ vertices.OutputIn case there is at least one vertex to delete, print the only line containing the indices of the vertices you will delete in the order you delete them. Otherwise print a single integer $-1$.Sample Input1Sample Output1Sample Input2Sample Output2Sample Input3Sample Output3HintThe deletion process in the first example is as follows (see the picture below, the vertices with $c_i=1$ are in yellow):first you will delete the vertex $1$, because it does not respect ancestors and all its children (the vertex $2$) do not respect it, and $1$ is the smallest index among such vertices;the vertex $2$ will be connected with the vertex $3$ after deletion;then you will delete the vertex $2$, because it does not respect ancestors and all its children (the only vertex $4$) do not respect it;the vertex $4$ will be connected with the vertex $3$;then you will delete the vertex $4$, because it does not respect ancestors and all its children (there are none) do not respect it (vacuous truth);you will just delete the vertex $4$;there are no more vertices to delete.In the second example you don’t need to delete any vertex:vertices $2$ and $3$ have children that respect them;vertices $4$ and $5$ respect ancestors.In the third example the tree will change this way:Solution我们统计出每一个父结点儿子的数量和不尊重父亲结点的数量，如果相等就全是不尊重父亲的结点，就是答案，所以我们统计完之后只需要枚举每一个点，条件为：儿子的数量等于不尊重父亲结点的数量父结点不为根节点自己也是不尊重父亲结点Code","tags":["题解","Codeforces","洛谷","C++","模拟"],"categories":["题解"]},{"title":"『题解』Codeforces1143B Nirvana","url":"/2019/12/11/『题解』Codeforces1143B Nirvana/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionKurt reaches nirvana when he finds the product of all the digits of some positive integer. Greater value of the product makes the nirvana deeper.Help Kurt find the maximum possible product of digits among all integers from $1$ to $n$.InputThe only input line contains the integer $n (1 \\le n \\le 2 \\times 10 ^ 9)$.OutputPrint the maximum product of digits among all integers from $1$ to $n$.Sample Input1Sample Output1Sample Input2Sample Output2Sample Input3Sample Output3Solution我们可以用递归，每次从右边少一位下去，进行递归，如果剩下的数是不为0的一位数，就返回这个数，否则返回1，然后枚举最后一位，选择直接用那一位的数或者退位。Code","tags":["题解","Codeforces","洛谷","C++","数论，数学"],"categories":["题解"]},{"title":"『题解』Codeforces1143A The Doors","url":"/2019/12/11/『题解』Codeforces1143A The Doors/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionThree years have passes and nothing changed. It is still raining in London, and Mr. Black has to close all the doors in his home in order to not be flooded. Once, however, Mr. Black became so nervous that he opened one door, then another, then one more and so on until he opened all the doors in his house.There are exactly two exits from Mr. Black’s house, let’s name them left and right exits. There are several doors in each of the exits, so each door in Mr. Black’s house is located either in the left or in the right exit. You know where each door is located. Initially all the doors are closed. Mr. Black can exit the house if and only if all doors in at least one of the exits is open. You are given a sequence in which Mr. Black opened the doors, please find the smallest index $k$ such that Mr. Black can exit the house after opening the first $k$ doors.We have to note that Mr. Black opened each door at most once, and in the end all doors became open.InputThe first line contains integer $n (2 \\le n \\le 200\\,000)$ — the number of doors.The next line contains $n$ integers: the sequence in which Mr. Black opened the doors. The $i$-th of these integers is equal to $0$ in case the $i$-th opened door is located in the left exit, and it is equal to $1$ in case it is in the right exit.It is guaranteed that there is at least one door located in the left exit and there is at least one door located in the right exit.OutputPrint the smallest integer $k$ such that after Mr. Black opened the first $k$ doors, he was able to exit the house.Sample Input1Sample Output1Sample Input2Sample Output2HintIn the first example the first two doors are from the left exit, so when Mr. Black opened both of them only, there were two more closed door in the left exit and one closed door in the right exit. So Mr. Black wasn’t able to exit at that moment.When he opened the third door, all doors from the right exit became open, so Mr. Black was able to exit the house.In the second example when the first two doors were opened, there was open closed door in each of the exit.With three doors opened Mr. Black was able to use the left exit.Solution题目很简单，实际上就是让我们从$n - 1$倒着枚举，求最后一个与数列最后的一个数字不同的是哪一个，输出它的编号就可以了。Code","tags":["题解","Codeforces","洛谷","C++","模拟"],"categories":["题解"]},{"title":"『题解』Codeforces1142B Lynyrd Skynyrd","url":"/2019/12/11/『题解』Codeforces1142B Lynyrd Skynyrd/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionRecently Lynyrd and Skynyrd went to a shop where Lynyrd bought a permutation $p$ of length $n$, and Skynyrd bought an array $a$ of length $m$, consisting of integers from $1$ to $n$.Lynyrd and Skynyrd became bored, so they asked you $q$ queries, each of which has the following form: “does the subsegment of $a$ from the $l$-th to the $r$-th positions, inclusive, have a subsequence that is a cyclic shift of $p$?” Please answer the queries.A permutation of length $n$ is a sequence of $n$ integers such that each integer from $1$ to $n$ appears exactly once in it.A cyclic shift of a permutation $(p_1, p_2, \\ldots, p_n)$ is a permutation $(p_i, p_{i + 1}, \\ldots, p_{n}, p_1, p_2, \\ldots, p_{i - 1})$ for some $i$ from $1$ to $n$. For example, a permutation $(2, 1, 3)$ has three distinct cyclic shifts: $(2, 1, 3)$, $(1, 3, 2)$, $(3, 2, 1)$.A subsequence of a subsegment of array $a$ from the $l$-th to the $r$-th positions, inclusive, is a sequence $a_{i_1}, a_{i_2}, \\ldots, a_{i_k}$ for some $i_1, i_2, \\ldots, i_k$ such that $l \\leq i_1 &lt; i_2 &lt; \\ldots &lt; i_k \\leq r$.InputThe first line contains three integers $n$, $m$, $q$ ($1 \\le n, m, q \\le 2 \\cdot 10^5$) — the length of the permutation $p$, the length of the array $a$ and the number of queries.The next line contains $n$ integers from $1$ to $n$, where the $i$-th of them is the $i$-th element of the permutation. Each integer from $1$ to $n$ appears exactly once.The next line contains $m$ integers from $1$ to $n$, the $i$-th of them is the $i$-th element of the array $a$.The next $q$ lines describe queries. The $i$-th of these lines contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le m$), meaning that the $i$-th query is about the subsegment of the array from the $l_i$-th to the $r_i$-th positions, inclusive.OutputPrint a single string of length $q$, consisting of $0$ and $1$, the digit on the $i$-th positions should be $1$, if the subsegment of array $a$ from the $l_i$-th to the $r_i$-th positions, inclusive, contains a subsequence that is a cyclic shift of $p$, and $0$ otherwise.Sample Input1Sample Output1Sample Input2Sample Output2HintIn the first example the segment from the $1$-st to the $5$-th positions is $1, 2, 3, 1, 2$. There is a subsequence $1, 3, 2$ that is a cyclic shift of the permutation. The subsegment from the $2$-nd to the $6$-th positions also contains a subsequence $2, 1, 3$ that is equal to the permutation. The subsegment from the $3$-rd to the $5$-th positions is $3, 1, 2$, there is only one subsequence of length $3$ ($3, 1, 2$), but it is not a cyclic shift of the permutation.In the second example the possible cyclic shifts are $1, 2$ and $2, 1$. The subsegment from the $1$-st to the $2$-nd positions is $1, 1$, its subsequences are not cyclic shifts of the permutation. The subsegment from the $2$-nd to the $3$-rd positions is $1, 2$, it coincides with the permutation. The subsegment from the $3$ to the $4$ positions is $2, 2$, its subsequences are not cyclic shifts of the permutation.Solution我们可以先预处理出$a_i$在$p$序列中的前一个数为$\\mathrm{last}_i$。如果它能构成一个合法的循环序列，就代表它能够向前位移$n - 1$次$\\mathrm{last}$。所以我们可以用倍增来解决。我们取一个最大的合法循环序列的头表示为$\\mathrm{b}_i$，那么最后的条件就是：$$\\max ^ {r} _ {i = l}{\\mathrm{b}_i} \\ge l$$满足就输出$1$，否则输出$0$。Code","tags":["题解","Codeforces","洛谷","C++","倍增","ST表"],"categories":["题解"]},{"title":"『题解』Codeforces1142A The Beatles","url":"/2019/12/11/『题解』Codeforces1142A The Beatles/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionRecently a Golden Circle of Beetlovers was found in Byteland. It is a circle route going through $n \\cdot k$ cities. The cities are numerated from $1$ to $n \\cdot k$, the distance between the neighboring cities is exactly $1$ km.Sergey does not like beetles, he loves burgers. Fortunately for him, there are $n$ fast food restaurants on the circle, they are located in the $1$-st, the $(k + 1)$-st, the $(2k + 1)$-st, and so on, the $((n-1)k + 1)$-st cities, i.e. the distance between the neighboring cities with fast food restaurants is $k$ km.Sergey began his journey at some city $s$ and traveled along the circle, making stops at cities each $l$ km ($l &gt; 0$), until he stopped in $s$ once again. Sergey then forgot numbers $s$ and $l$, but he remembers that the distance from the city $s$ to the nearest fast food restaurant was $a$ km, and the distance from the city he stopped at after traveling the first $l$ km from $s$ to the nearest fast food restaurant was $b$ km. Sergey always traveled in the same direction along the circle, but when he calculated distances to the restaurants, he considered both directions.Now Sergey is interested in two integers. The first integer $x$ is the minimum number of stops (excluding the first) Sergey could have done before returning to $s$. The second integer $y$ is the maximum number of stops (excluding the first) Sergey could have done before returning to $s$.InputThe first line contains two integers $n$ and $k$ ($1 \\le n, k \\le 100\\,000$) — the number of fast food restaurants on the circle and the distance between the neighboring restaurants, respectively.The second line contains two integers $a$ and $b$ ($0 \\le a, b \\le \\frac{k}{2}$) — the distances to the nearest fast food restaurants from the initial city and from the city Sergey made the first stop at, respectively.OutputPrint the two integers $x$ and $y$.Sample Input1Sample Output1Sample Input2Sample Output2Sample Input3Sample Output3HintIn the first example the restaurants are located in the cities $1$ and $4$, the initial city $s$ could be $2$, $3$, $5$, or $6$. The next city Sergey stopped at could also be at cities $2, 3, 5, 6$. Let’s loop through all possible combinations of these cities. If both $s$ and the city of the first stop are at the city $2$ (for example, $l = 6$), then Sergey is at $s$ after the first stop already, so $x = 1$. In other pairs Sergey needs $1, 2, 3$, or $6$ stops to return to $s$, so $y = 6$.In the second example Sergey was at cities with fast food restaurant both initially and after the first stop, so $l$ is $2$, $4$, or $6$. Thus $x = 1$, $y = 3$.In the third example there is only one restaurant, so the possible locations of $s$ and the first stop are: $(6, 8)$ and $(6, 4)$. For the first option $l = 2$, for the second $l = 8$. In both cases Sergey needs $x=y=5$ stops to go to $s$.Solution我们根据题目的$a, b, k$计算出$l$的$4$种可能：$a + b$$k - a + b$$k + a - b$$k - a - b$每走一步的答案就是$\\frac{n \\times k}{\\gcd(n \\times k, step)}$。然后枚举找个最大的与最小的就可以了。Code","tags":["题解","Codeforces","洛谷","C++","数论，数学"],"categories":["题解"]},{"title":"『题解』Codeforces888D Almost Identity Permutations","url":"/2019/12/11/『题解』Codeforces888D Almost Identity Permutations/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionA permutation $p$ of size $n$ is an array such that every integer from $1$ to $n$ occurs exactly once in this array.Let’s call a permutation an almost identity permutation iff there exist at least $n - k$ indices $i (1 \\le i \\le n)$ such that $p_i = i$.Your task is to count the number of almost identity permutations for given numbers n and k.InputThe first line contains two integers $n$ and $k (4 \\le n \\le 1000, 1 \\le k \\le 4)$.OutputPrint the number of almost identity permutations for given $n$ and $k$.Sample Input1Sample Output1Sample Input2Sample Output2Sample Input3Sample Output3Sample Input4Sample Output4Description in Chinese给出$n$和$k$计算满足至少有$n - k$个位置的值$a_i = i$的$1 \\sim n$的全排列的个数。Solution观察题目，发现$k$的范围是$1 \\sim 4$，我们不妨来分类讨论。当$k = 1$时，有$n - 1$个位置的数是固定的，也就是有$1$个位置是自由的，呵呵，因为要填$1 \\sim n$，发现填的数也只有一种。当$k = 2$时，有$n - 2$个位置是固定的，还有$2$个位置是可以自由填数的，选位置的方案有$\\binom{n}{2}$，我们先计算有$n - 2$个位置固定且仅有$n - 2$个位置固定的情况，每一个选位置的方案可以有$(2 - 1) \\times  = 1$种放法，因为每一个位置不能填自己的编号。所以一共有$\\binom{n}{2} \\times 1$种，然后再加上$k = 1$的情况，即答案为$\\binom{n}{2} \\times 1 + 1 =\\binom{n}{2} + 1$。当$k = 3$时，同情况$2$，答案为$\\binom{n}{3} \\times 2 + \\binom{n}{2} \\times 1 + 1 = 2 \\times \\binom{n}{3} + \\binom{n}{2} + 1$。当$k = 4$时，同情况$2$，答案为$\\binom{n}{4} \\times 9 + \\binom{n}{3} \\times 2 + \\binom{n}{2} \\times 1 + 1 = 9 \\times \\binom{n}{4} + 2 \\times \\binom{n}{3} + \\binom{n}{2} + 1$。Code","tags":["题解","Codeforces","洛谷","C++","数论，数学"],"categories":["题解"]},{"title":"『题解』Codeforces888B Buggy Robot","url":"/2019/12/11/『题解』Codeforces888B Buggy Robot/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionIvan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell $(0, 0)$. The robot can process commands. There are four types of commands it can perform:$\\mathrm{U}$ — move from the cell $(x, y)$ to $(x, y + 1)$;$\\mathrm{D}$ — move from $(x, y)$ to $(x, y - 1)$;$\\mathrm{L}$ — move from $(x, y)$ to $(x - 1, y)$;$\\mathrm{R}$ — move from $(x, y)$ to $(x + 1, y)$.Ivan entered a sequence of $n$ commands, and the robot processed it. After this sequence the robot ended up in the starting cell $(0, 0)$, but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!InputThe first line contains one number $n$ — the length of sequence of commands entered by Ivan $(1  \\leq n  \\leq 100)$.The second line contains the sequence itself — a string consisting of $n$ characters. Each character can be $\\mathrm{U}$, $\\mathrm{D}$, $\\mathrm{L}$ or $\\mathrm{R}$.OutputPrint the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.Sample Input1Sample Output1Sample Input2Sample Output2Sample Input3Sample Output3Description in Chinese给你一个字符串，让你求$2 \\times (\\min(\\texttt{‘L’的个数, ‘R’的个数}) + \\min(\\texttt{‘U’的个数，’D’的个数}))$。Solution给你一个字符串，先计算出$\\mathrm{L}$，$\\mathrm{R}$，$\\mathrm{U}$，$\\mathrm{D}$的个数，最后按题目给出的表达式输出即可。Code","tags":["题解","Codeforces","洛谷","C++","字符串","模拟"],"categories":["题解"]},{"title":"『题解』Codeforces735D Taxes","url":"/2019/12/11/『题解』Codeforces735D Taxes/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionMr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to $n (n \\le 2)$ burles and the amount of tax he has to pay is calculated as the maximum divisor of $n$ (not equal to $n$, of course). For example, if $n = 6$ then Funt has to pay $3$ burles, while for $n = 25$ he needs to pay $5$ and if $n = 2$ he pays only $1$ burle.As mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial $n$ in several parts $n_1 + n_2 + \\cdots + n_k = n$ (here $k$ is arbitrary, even $k = 1$ is allowed) and pay the taxes for each part separately. He can’t make some part equal to $1$ because it will reveal him. So, the condition $n_i \\le 2$ should hold for all i from $1$ to $k$.Ostap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split $n$ in parts.InputThe first line of the input contains a single integer $n (2 \\le n \\le 2 \\times 10^9)$ — the total year income of mr. Funt.OutputPrint one integer — minimum possible number of burles that mr. Funt has to pay as a tax.Sample Input1Sample Output1Sample Input2Sample Output2Description in Chinese某人要交税，交的税钱是收入$n$的最大因子（$\\ne n$，若该数是素数则是$1$），但是现在这人为了避税，把钱拆成几份，使交税最少，输出税钱。Solution当$n$为素数时，显然答案为$1$；当$n$为偶数时，可以分成两个素数，也就是两个$1$，所以答案为$2$；当$n$为奇数且$n - 2$为素数时，也就是它能分成两个素数，也就是两个$1$，所以答案也是$2$；当$n$为奇数且$n - 2$不是素数时，可以分成$3$和一个偶数，偶数又可以分成$2$个素数。所以总共分成了$3$个素数，因此答案为$3$。Code","tags":["题解","Codeforces","洛谷","C++","数论，数学"],"categories":["题解"]},{"title":"『题解』Codeforces446C DZY Loves Fibonacci Numbers","url":"/2019/12/11/『题解』Codeforces446C DZY Loves Fibonacci Numbers/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionIn mathematical terms, the sequence $F_n$ of Fibonacci numbers is defined by the recurrence relation$$F_1 = 1; F_2 = 1; F_n = F_n - 1 + F_n - 2 (n &gt; 2)$$DZY loves Fibonacci numbers very much. Today DZY gives you an array consisting of $n$ integers: $a1, a2, \\cdots , an$. Moreover, there are $m$ queries, each query has one of the two types:Format of the query “1 l r“. In reply to the query, you need to add $F_i - l + 1$ to each element ai, where $l \\le i \\le r$.Format of the query “2 l r“. In reply to the query you should output the value of  modulo $1000000009 (10^9 + 9)$.Help DZY reply to all the queries.InputThe first line of the input contains two integers $n$ and $m (1 \\le n, m \\le 300000)$. The second line contains $n$ integers $a_1, a_2, \\cdots , a_n (1 \\le ai \\le 10^9)$ — initial array $a$ .Then, $m$ lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality $1 \\le l \\le r \\le n$ holds.OutputFor each query of the second type, print the value of the sum on a single line.Sample InputSample OutputSample ExplainAfter the first query, $a = [2, 3, 5, 7]$.For the second query, $sum = 2 + 3 + 5 + 7 = 17$.After the third query, $a = [2, 4, 6, 9]$.For the fourth query, $sum = 2 + 4 + 6 = 12$.Description in Chinese题目让我们求给你一个序列，支持区间加Fibonacci数列前r - l + 1项和查询区间和。Solution一些约定：把斐波那契数列的前两个数$F_1 = 1, F_2 = 1$换成另两个数，仍满足$F_n = F_{n - 1} + F_{n - 2}(n &gt; 2)$的数列称为广义斐波那契数列。Fibonacci数列有一些性质：性质$1$. $F_n = (\\sum^{n - 2}_{i = 1}{F_i}) + F_2(n &gt; 2)$；证明如下：首先将前几项Fibonacci数列展开。在$F_n = F_{n - 1} + F_{n - 2}$中，我们可以把$F_{n - 1}$按式子展开，可得$F_n = \\sum^{n - 3}_{i = 1}{F_i} + F_2 + F_{n - 2}$，即$F_n = (\\sum^{n - 2}_{i = 1}{F_i}) + F_2(n &gt; 2)$，跟原式一模一样，故原式正确性得证。性质$2$. 一个广义斐波那契数列数列$f_i$， 当$f_1 = x, f_2 = y$时，则有$f_n = x \\times f_{n - 1} + y \\times f_{n - 2}$证明如下：这个性质与性质1类似，证明方法也与性质1类似，列举几个：把上述规律推广到代数式：$$\\begin{aligned} f_n &amp; = f_{n - 1} + f_{n - 2} \\\\ &amp; = x \\times f_{n - 2} + y \\times f_{n - 3} + x \\times f_{n - 3} + y \\times f_{n - 4} \\\\ &amp; = x \\times (f_{n - 2} + f_{n - 3}) + y \\times (f_{n - 3} + f_{n - 4}) \\\\ &amp; = x \\times f_{n - 1} + y \\times f_{n - 2} \\end{aligned}$$证毕。性质$3$. 任意两段不同的广义斐波那契数列段相加（逐项相加），所得的数列任然是广义斐波那契数列。这个性质易证。这题我们维护一棵线段树，线段树需要维护$L$至$R$区间的广义斐波那契数列的第一项，第二项与区间的和。下传标记时，我们可以在左区间加广义斐波那契数列的前两项，在右区间可以求出总和再加上总和就行了，时间复杂$\\text{O(n log n)}$。Code","tags":["题解","Codeforces","洛谷","C++","线段树"],"categories":["题解"]},{"title":"『题解』Codeforces121A Lucky Sum","url":"/2019/12/11/『题解』Codeforces121A Lucky Sum/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionPetya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits $4$ and $7$. For example, numbers $47$, $744$, $4$ are lucky and $5$, $17$, $467$ are not.Let $next(x)$ be the minimum lucky number which is larger than or equals $x$. Petya is interested what is the value of the expression $next(l) + next(l + 1) + \\cdots + next(r - 1) + next(r)$. Help him solve this problem.InputThe single line contains two integers $l$ and $r (1 \\le l \\le r \\le 10^9)$ - the left and right interval limits.OutputIn the single line print the only number - the sum $next(l) + next(l + 1) + … + next(r - 1) + next(r)$.Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.Sample Input1Sample Output1Sample Input2Sample Output2Sample ExplainIn the first sample: $next(2) + next(3) + next(4) + next(5) + next(6) + next(7) = 4 + 4 + 4 + 7 + 7 + 7 = 33$In the second sample: $next(7) = 7$Description in ChinesePetya喜欢Lucky Number。仅含有数字$4$和$7$的数字是一个Lucky Number。规定$next(x)$等于最小的大于等于$x$的Lucky Number。现在Petya想知道$next(l) + next(l + 1) + \\cdots + next(r - 1) + next(r)$Solution我们可以先预处理出所有的Lucky Number。在询问时，我们可以采用前缀和的思想，题目中的询问可转换为：$$\\sum^{r}_{i = l} \\mathrm{next}(i) \\\\ = \\sum^{r}_{i = 1}{\\mathrm{next}(i)}- \\sum^{l - 1}_{i = 1}{\\mathrm{next}(i)}$$当我们在询问$\\sum^{x}_{i = 1}{\\mathrm{next}(i)}$是，如果一个个暴力枚举一定会超时。所以我们可以把连续的一段（第一个大于等于$x$的值相同的数）一起加起来。Code","tags":["题解","Codeforces","洛谷","C++","数论，数学"],"categories":["题解"]},{"title":"『题解』Codeforces9D How many trees?","url":"/2019/12/11/『题解』Codeforces9D How many trees/","content":"PortalPortal1: CodeforcesPortal2: LuoguDescriptionIn one very old text file there was written Great Wisdom. This Wisdom was so Great that nobody could decipher it, even Phong - the oldest among the inhabitants of Mainframe. But still he managed to get some information from there. For example, he managed to learn that User launches games for pleasure - and then terrible Game Cubes fall down on the city, bringing death to those modules, who cannot win the game…For sure, as guard Bob appeared in Mainframe many modules stopped fearing Game Cubes. Because Bob (as he is alive yet) has never been defeated by User, and he always meddles with Game Cubes, because he is programmed to this.However, unpleasant situations can happen, when a Game Cube falls down on Lost Angles. Because there lives a nasty virus - Hexadecimal, who is… mmm… very strange. And she likes to play very much. So, willy-nilly, Bob has to play with her first, and then with User.This time Hexadecimal invented the following entertainment: Bob has to leap over binary search trees with n nodes. We should remind you that a binary search tree is a binary tree, each node has a distinct key, for each node the following is true: the left sub-tree of a node contains only nodes with keys less than the node’s key, the right sub-tree of a node contains only nodes with keys greater than the node’s key. All the keys are different positive integer numbers from $1$ to $n$. Each node of such a tree can have up to two children, or have no children at all (in the case when a node is a leaf).In Hexadecimal’s game all the trees are different, but the height of each is not lower than h. In this problem «height» stands for the maximum amount of nodes on the way from the root to the remotest leaf, the root node and the leaf itself included. When Bob leaps over a tree, it disappears. Bob gets the access to a Cube, when there are no trees left. He knows how many trees he will have to leap over in the worst case. And you?InputThe input data contains two space-separated positive integer numbers $n$ and $h (n \\le 35, h \\le n)$.OutputOutput one number - the answer to the problem. It is guaranteed that it does not exceed $9 \\times 10^18$.Sample Input1Sample Output1Sample Input2Sample Output2Description in Chinese用$n$个点组成二叉树，问高度大于等于$h$的有多少个。Solution这题$n$的范围很小，只有$35$，所以我们用$O(n^4)$的动态规划来解决。dp[i][j]表示用$i$个点，构成高度为$j$的二叉树的个数。动态转移方程为$dp[i][max(j, k) + 1] += dp[L][j] \\times dp[R][k]$，其中$i$表示所用的结点数，$j$是枚举左子树的结点数，$L$表示左子树的结点总数，$k$是枚举左子树的结点数，$R$表示右子树的结点总数。答案就是$\\sum^{n}_{i = h}{dp[n][i]}$。Code","tags":["题解","Codeforces","洛谷","C++","动态规划"],"categories":["题解"]},{"title":"『题解』AT1350 深さ優先探索","url":"/2019/12/11/『题解』AT1350 深さ優先探索/","content":"PortalPortal1: AtCoderPortal2: LuoguDescriptionこの問題は、講座用問題です。ページ下部に解説が掲載されています。高橋君の住む街は長方形の形をしており、格子状の区画に区切られています。 長方形の各辺は東西及び南北に並行です。 各区画は道または塀のどちらかであり、高橋君は道を東西南北に移動できますが斜めには移動できません。 また、塀の区画は通ることができません。高橋君が、塀を壊したりすることなく道を通って魚屋にたどり着けるかどうか判定してください。Input入力は以下の形式で標準入力から与えられる。$$H W \\\\ c_{0, 0} c_{0, 1} \\cdots  c_{0, w - 1} \\\\ c_{1, 0} c_{1, 1} \\cdots  1_{0, w - 1} \\\\ \\cdots \\cdots \\\\ c_{H, 0} c_{H, 1} \\cdots  1_{H, w - 1}$$$1$行目には、街の南北の長さとして整数$H(1 \\le H \\le 500)$と東西の長さとして整数$W(1 \\le W \\le 500)$が空白で区切られて与えられる。$2$行目からの$H$行には、格子状の街の各区画における状態$c_{i, j} (0 \\le i \\le H - 1, 0 \\le j \\le W - 1)$が与えられる。$i$行目$j$文字目の文字$c_{i, j}$はそれぞれs, g, ., #のいずれかで与えられ、座標$(j, i)$が下記のような状態であることを表す。s : その区画が家であることを表す。g : その区画が魚屋であることを表す。. : その区画が道であることを表す。# : その区画が塀であることを表す。高橋君は家·魚屋·道は通ることができるが、塀は通ることができない。与えられた街の外を通ることはできない。sとgはそれぞれ$1$つずつ与えられる。Output塀を$1$回も壊さずに、家から魚屋まで辿り着くことができる場合はYes、辿りつけない場合はNoを標準出力に$1$行で出力せよ。Sample Input1Sample Output1Sample Input2Sample Output2Sample Input3Sample Output3Sample Input4Sample Output4Description in Chinese高桥先生住的小区是长方形的，被划分成一个个格子。高桥先生想从家里去鱼店，高桥先生每次可以走到他上下左右四个格子中的其中一个，不能斜着走，也不能走出小区或穿墙。地图语言解释：s：表示高桥先生的家（起始点）g：表示鱼店（终点）.：表示道路#：表示墙壁Solution我们不妨采用深度优先搜索，先在地图上找出起始点，然后用灌水法（将起始点能到达的地方标记），我是直接修改地图的，最后再扫描一边地图，看看终点还在不在，如果在就表示还没标记过，也就是走不到，输出No，如果终点不存在，也就是被标记了，就说明可以到达，输出Yes。Code","tags":["题解","洛谷","C++","搜索","AtCoder"],"categories":["题解"]},{"title":"「POJ 3268」Silver Cow Party","url":"/2019/12/11/「POJ 3268」Silver Cow Party/","content":"PortalPortal1: POJPortal2: LuoguDescriptionOne cow from each of N farms $(1  \\le  N  \\le  1000)$ conveniently numbered $1 \\cdots N$ is going to attend the big cow party to be held at farm #X $(1  \\le  X  \\le  N)$. A total of $M (1  \\le  M  \\le  100,000)$ unidirectional (one-way roads connects pairs of farms; road $i$ requires $T_i (1  \\le  Ti  \\le  100)$ units of time to traverse.Each cow must walk to the party and, when the party is over, return to her farm. Each cow is lazy and thus picks an optimal route with the shortest time. A cow’s return route might be different from her original route to the party since roads are one-way.Of all the cows, what is the longest amount of time a cow must spend walking to the party and back?寒假到了，$N$头牛都要去参加一场在编号为$X$（$1 \\le X \\le N$）的牛的农场举行的派对（$1 \\le N \\le 1000$），农场之间有$M$（$1 \\le M \\le 100000$）条有向路，每条路长$Ti$（$1 \\le Ti \\le 100$）。每头牛参加完派对后都必须回家，无论是去参加派对还是回家，每头牛都会选择最短路径，求这N头牛的最短路径（一个来回）中最长的一条路径长度。Input第一行三个整数$N$，$M$，$X$；第二行到第$M + 1$行：每行有三个整数$A_i$，$B_i$，$T_i$ ,表示有一条从$A_i$农场到$B_i$农场的道路，长度为$T_i$。Output一个整数，表示最长的最短路得长度。Sample InputSample OutputHintSolution题目让我们一些奶牛走到一个点，再从那个点走回来的最短路之和的最大值。那么我们直接用dijkstra计算两次最短路（走过去，走回来）就可以了，最后判断一下，那头奶牛需要走的路是最长的，然后问题就解决了。Code","tags":["题解","C++","最短路","dijkstra","SPFA","POJ"],"categories":["题解"]},{"title":"「Luogu 5635」【CSGRound1】天下第一","url":"/2019/12/11/「Luogu 5635」【CSGRound1】天下第一/","content":"PortalPortal1: LuoguDescription给定两个数$x$,$y$，与一个模数$Mod$。cbw拥有数$x$，zwc拥有数$y$。第一个回合：$x = (x + y) \\% Mod$第二个回合：$y = (x + y) \\% Mod$第三个回合：$x = (x + y) \\% Mod$第四个回合：$y = (x + y) \\% Mod$以此类推$\\cdots \\cdots$如果$x$先到$0$，则cbw胜利。如果$y$先到$0$，则zwc胜利。如果$x, y$都不能到$0$，则为平局。cbw为了捍卫自己主席的尊严，想要提前知道游戏的结果，并且可以趁机动点手脚，所以他希望你来告诉他结果。Input有多组数据：第一行：$T$和$Mod$ 表示一共有$T$组数据且模数都为$Mod$；以下$T$行，每行两个数$x, y$。Output$1$表示cbw获胜，$2$表示zwc获胜，$error$表示平局。Sample Input1Sample Output1Sample Input2Sample Output2Hint对于$5 \\%$的数据，满足输出全是$error$；对于$100 \\%$的数据，满足$1 \\le T \\le 200$，$1 \\le X, Y, MOD \\le 10000$。Solution这题很容易看出来是记忆化搜索，我们对于每一次询问的每一次答案都记录下来，在下一次的搜索中，如果有这个答案了，就直接输出，否则继续搜索并记录，直到出现过为止。但是$10000 \\times 10000$的$\\rm{int}$数组会$\\rm{MLE}$，于是我们可以用$\\rm{short}$类型来存储记忆化搜索的结果。附：$10000 \\times 10000$的$\\rm{int}$类型的数组内存是$\\rm{381.47MB}$，$10000 \\times 10000$的$\\rm{short}$类型的数组内存是$\\rm{190.735MB}$。所以此题用$\\rm{int}$类型会爆空间Code","tags":["题解","洛谷","C++","记忆化搜索"],"categories":["题解"]},{"title":"「Luogu 2367」语文成绩","url":"/2019/12/11/「Luogu 2367」语文成绩/","content":"PortalPortal1: LuoguDescription语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？Input第一行有两个整数$n$，$p$，代表学生数与增加分数的次数。第二行有$n$个数，$a_1 \\sim a_n$，代表各个学生的初始成绩。接下来$p$行，每行有三个数，$x$，$y$，$z$，代表给第$x$个到第$y$个学生每人增加$z$分。Output输出仅一行，代表更改分数后，全班的最低分。Sample InputSample OutputHint对于$40\\%$的数据，有$n \\le 1000$；对于$60\\%$的数据，有$n \\le 10000$；对于$80\\%$的数据，有$n \\le 100000$；对于$100\\%$的数据，有$n \\le 5000000，p \\le n$，学生初始成绩$\\le 100$，$z \\le 100$。Solution这题介绍一种$O(n)$的算法。可以用差分数组来做，在修改的时候，第一个数加$x$，第$n+1$个数减$x$，类似于一个懒标记，查询的时候累加一下，再加上本身就是这个数的最终值。Code","tags":["题解","C++","线段树","分块","差分"],"categories":["题解"]},{"title":"「Luogu 1821」[USACO07FEB]银牛派对Silver Cow Party","url":"/2019/12/11/「Luogu 1821」[USACO07FEB]银牛派对Silver Cow Party/","content":"PortalPortal1: LuoguPortal2: POJDescriptionOne cow from each of N farms $(1  \\le  N  \\le  1000)$ conveniently numbered $1 \\cdots N$ is going to attend the big cow party to be held at farm #X $(1  \\le  X  \\le  N)$. A total of $M (1  \\le  M  \\le  100,000)$ unidirectional (one-way roads connects pairs of farms; road $i$ requires $T_i (1  \\le  Ti  \\le  100)$ units of time to traverse.Each cow must walk to the party and, when the party is over, return to her farm. Each cow is lazy and thus picks an optimal route with the shortest time. A cow’s return route might be different from her original route to the party since roads are one-way.Of all the cows, what is the longest amount of time a cow must spend walking to the party and back?寒假到了，$N$头牛都要去参加一场在编号为$X$（$1 \\le X \\le N$）的牛的农场举行的派对（$1 \\le N \\le 1000$），农场之间有$M$（$1 \\le M \\le 100000$）条有向路，每条路长$Ti$（$1 \\le Ti \\le 100$）。每头牛参加完派对后都必须回家，无论是去参加派对还是回家，每头牛都会选择最短路径，求这N头牛的最短路径（一个来回）中最长的一条路径长度。Input第一行三个整数$N$，$M$，$X$；第二行到第$M + 1$行：每行有三个整数$A_i$，$B_i$，$T_i$ ,表示有一条从$A_i$农场到$B_i$农场的道路，长度为$T_i$。Output一个整数，表示最长的最短路得长度。Sample InputSample OutputHintSolution题目让我们一些奶牛走到一个点，再从那个点走回来的最短路之和的最大值。那么我们直接用dijkstra计算两次最短路（走过去，走回来）就可以了，最后判断一下，那头奶牛需要走的路是最长的，然后问题就解决了。Code","tags":["题解","C++","最短路","dijkstra","SPFA","POJ"],"categories":["题解"]},{"title":"「Luogu 1525」关押罪犯","url":"/2019/12/11/「Luogu 1525」关押罪犯/","content":"PortalPortal1: LuoguPortal2: LibreOJDescription$S$城现有两座监狱，一共关押着$N$名罪犯，编号分别为$1 - N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为$c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为$c$的冲突事件。每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。在详细考察了$N$名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那么，应如何分配罪犯，才能使$\\rm Z$市长看到的那个冲突事件的影响力最小？这个最小值是多少？Input每行中两个数之间用一个空格隔开。第一行为两个正整数$N, M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的$M$行每行为三个正整数$a_j, b_j, c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证$1&lt;aj \\le b_j \\le N ,0 &lt; cj \\le 1, 000, 000, 000$，且每对罪犯组合只出现一次。Output共$1$ 行，为$\\rm Z$市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出$0$。Sample InputSample OutputHint【输入输出样例说明】罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是$3512$（由$2$号和$3$号罪犯引发）。其他任何分法都不会比这个分法更优。  【数据范围】  对于$30\\%$的数据有$N \\le 15$。对于$70\\%$的数据有$N \\le 2000,M \\le 50000$。对于$100\\%$的数据有$N \\le 20000,M \\le 100000$。Solution题目要把罪犯们放到两个监狱，很容易想到是二分图。我们可以先用二分答案，对于每一条大于二分出来的边（也就是不能放在一个监狱的两个罪犯，放入了答案就大于二分的值了）构成的图，判断是否能构成二分图，也就是是否可以将这些点分到两个区域。如果可以，那么说明了这个最大破坏度是可行的，所以就扩大二分值，最后求出最大值的最小值。CodeAttachment测试数据下载：https://www.lanzous.com/i7ayq3a","tags":["题解","洛谷","C++","二分","图论","二分图","并查集","NOIP","LibreOJ"],"categories":["题解"]},{"title":"Hello World","url":"/2019/12/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new postMore info: WritingRun serverMore info: ServerGenerate static filesMore info: GeneratingDeploy to remote sitesMore info: Deployment"}]